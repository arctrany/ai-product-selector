<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>工作流控制台 - {{ app_name }}/{{ flow_name }}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 14px;
        }

        .main-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .control-section {
            padding: 20px;
            border-bottom: 1px solid #ecf0f1;
            background: #f8f9fa;
        }

        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .form-group {
            flex: 1;
            min-width: 300px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #2c3e50;
        }

        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
            min-height: 80px;
        }

        .status-display {
            background: #fff;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            min-width: 250px;
        }

        .status-display h4 {
            margin-bottom: 10px;
            color: #495057;
            font-size: 14px;
        }

        .logs-section {
            padding: 20px;
        }

        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .logs-header h3 {
            color: #2c3e50;
            margin: 0;
        }

        .logs-controls {
            display: flex;
            gap: 10px;
        }

        .logs {
            background: #1e1e1e;
            color: #e0e0e0;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #333;
        }

        .log-entry {
            margin-bottom: 2px;
            padding: 2px 0;
        }

        .log-info { color: #4CAF50; }
        .log-warning { color: #FF9800; }
        .log-error { color: #f44336; }
        .log-debug { color: #9E9E9E; }
        .log-success { color: #8BC34A; }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-block;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #218838, #1ea080);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107, #fd7e14);
            color: #212529;
        }

        .btn-warning:hover {
            background: linear-gradient(135deg, #e0a800, #e8590c);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545, #e83e8c);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #c82333, #d91a72);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-idle {
            background: #e9ecef;
            color: #495057;
        }

        .status-running {
            background: #d4edda;
            color: #155724;
        }

        .status-paused {
            background: #fff3cd;
            color: #856404;
        }

        .status-stopped {
            background: #f8d7da;
            color: #721c24;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        .connection-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background: #dc3545;
            animation: none;
        }

        .status-dot.connecting {
            background: #ffc107;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* 执行状态和计时器优化布局 */
        .execution-info {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .execution-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .execution-status {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-value {
            font-size: 16px;
            font-weight: 700;
            padding: 6px 16px;
            border-radius: 8px;
            display: inline-block;
            min-width: 100px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .status-display {
            font-size: 14px;
            font-weight: 600;
            display: inline;
            margin-left: 8px;
        }

        /* 状态颜色样式 */
        .status-display.idle {
            color: #28a745;
        }

        .status-display.running {
            color: #dc3545;
        }

        .status-display.paused {
            color: #ffc107;
        }

        .status-display.completed {
            color: #17a2b8;
        }

        .status-display.failed,
        .status-display.error,
        .status-display.cancelled,
        .status-display.timeout {
            color: #dc3545;
        }

        .status-display.stopped {
            color: #6c757d;
        }

        .status-display.pending {
            color: #17a2b8;
        }

        .execution-connection {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .connection-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .connection-display {
            font-size: 14px;
            font-weight: 600;
            display: inline;
            margin-left: 8px;
            color: #28a745;
        }

        .execution-timer {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .timer-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .timer-display {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .timer-display:hover {
            transform: translateY(-1px);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1), 0 4px 12px rgba(0,0,0,0.15);
        }

        .timer-status {
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .timer-status.running {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border: 1px solid #c3e6cb;
            animation: pulse-green 2s infinite;
        }

        .timer-status.paused {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .timer-status.stopped {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .timer-status.completed {
            background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .timer-status.idle {
            background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
            color: #383d41;
            border: 1px solid #d6d8db;
        }

        @keyframes pulse-green {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        /* 状态指示器样式优化 */
        .status.status-running {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
        }

        .status.status-paused {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #212529;
            box-shadow: 0 2px 4px rgba(255, 193, 7, 0.3);
        }

        .status.status-completed {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(23, 162, 184, 0.3);
        }

        .status.status-stopped {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);
        }

        .status.status-failed {
            background: linear-gradient(135deg, #dc3545 0%, #bd2130 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);
        }

        .status.status-idle {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(108, 117, 125, 0.3);
        }

        .execution-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: #6c757d;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e9ecef;
        }

        .last-update {
            font-style: italic;
            font-weight: 500;
        }

        /* 响应式优化 */
        @media (max-width: 768px) {
            .execution-header {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }

            .execution-timer {
                align-items: center;
            }

            .timer-display {
                font-size: 28px;
                min-width: 140px;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            .header-right {
                text-align: center;
            }

            .header-right .status-display {
                min-width: auto;
                width: 100%;
            }

            .control-row {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                justify-content: center;
            }

            .logs-header {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .logs-controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1>工作流控制台</h1>
                <p>应用: {{ app_name }} | 流程: {{ flow_name }} | 版本: {{ version_info }}</p>
            </div>
            <div class="header-right">
                <div class="execution-info">
                    <div class="execution-header">
                        <div class="execution-status">
                            <span class="status-label">执行状态：<span id="status-info" class="status-display">空闲</span></span>
                        </div>
                        <div class="execution-timer">
                            <span class="timer-label">执行时间：<span id="timer-display" class="timer-display">00:00:00</span></span>
                        </div>
                        <div class="execution-connection">
                            <span class="connection-label">连接状态：<span id="connection-status" class="connection-display">已连接</span></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <!-- 工作流控制区域 -->
            <div class="control-section">
                <div class="control-row">
                    <div class="control-group">
                        <button id="start-pause-btn" class="btn btn-success" onclick="toggleStartPause()">开始任务</button>
                        <button class="btn btn-danger" onclick="stopFlow()">停止流程</button>
                    </div>
                </div>

            </div>

            <!-- 执行日志区域 -->
            <div class="logs-section">
                <div class="logs-header">
                    <h3>执行日志</h3>
                    <div class="logs-controls">
                        <button class="btn btn-secondary" onclick="loadLogs()">刷新日志</button>
                        <button class="btn btn-secondary" onclick="clearLogs()">清空日志</button>
                        <button class="btn btn-primary" onclick="refreshStatus()">刷新状态</button>
                    </div>
                </div>
                <div id="logs-container" class="logs">
                    <p>暂无日志记录</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 流程上下文
        const flowContext = {{ flow_context | tojson }};
        const appName = "{{ app_name }}";
        const flowName = "{{ flow_name }}";

        // 启动工作流 (新的主要启动函数，携带提交阶段生成的 thread_id)
        function startWorkflow() {
            console.log('启动工作流:', flowName);
            addLog('info', '正在启动工作流...');

            const flowId = "{{ flow_id }}";
            const apiUrl = `/api/flows/${flowId}/start/latest`;
            addLog('debug', `调用API: ${apiUrl}`);

            // 从URL获取提交阶段生成的thread_id
            const urlParams = new URLSearchParams(window.location.search);
            const pendingThreadId = urlParams.get('thread_id') || null;

            // 调用后端API启动工作流（如果存在pendingThreadId则复用）
            fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    input_data: {},
                    thread_id: pendingThreadId
                })
            })
            .then(async response => {
                addLog('debug', `API响应状态: ${response.status}`);
                const data = await response.json();

                if (!response.ok) {
                    const errorMsg = data.detail || data.message || `HTTP ${response.status} 错误`;
                    throw new Error(errorMsg);
                }
                return data;
            })
            .then(data => {
                console.log('API响应数据:', data);

                if (data.thread_id) {
                    addLog('success', `✅ 工作流启动成功！Thread ID: ${data.thread_id}`);
                    updateStatus('running');
                    updateButtonState(true); // 切换到"暂停任务"状态
                    startTimer(); // 启动计时器
                    addLog('info', `📋 流程ID: ${data.flow_id}`);
                    addLog('info', `📋 版本: ${data.version}`);
                    addLog('info', `📋 状态: ${data.status}`);

                    if (data.inputs && Object.keys(data.inputs).length > 0) {
                        addLog('info', '📝 输入数据:');
                        displayInputData(data.inputs);
                    }

                    if (urlParams.get('form_data') === 'submitted') {
                        displayFormData(data.inputs || {});
                    }

                    startLogPolling(data.thread_id);
                } else {
                    const errorMsg = data.detail || data.message || '未知错误';
                    addLog('error', `❌ 启动失败: ${errorMsg}`);
                    console.error('启动失败详情:', data);
                }
            })
            .catch(error => {
                console.error('启动工作流失败:', error);
                addLog('error', `❌ 启动失败: ${error.message}`);

                if (error.message.includes('404')) {
                    addLog('warning', '💡 提示: 请检查流程ID是否正确，或流程是否已发布');
                } else if (error.message.includes('500')) {
                    addLog('warning', '💡 提示: 服务器内部错误，请检查工作流定义或联系管理员');
                } else if (error.message.includes('400')) {
                    addLog('warning', '💡 提示: 请求参数错误，请检查输入数据格式');
                }
            });
        }

        // 显示输入数据（格式化到日志中）
        function displayInputData(inputData) {
            Object.entries(inputData).forEach(([key, value]) => {
                let displayValue;
                if (typeof value === 'object') {
                    displayValue = JSON.stringify(value, null, 2);
                } else {
                    displayValue = String(value);
                }
                addLog('info', `   ${key}: ${displayValue}`);
            });
        }

        // 显示表单数据
        function displayFormData(formData) {
            if (Object.keys(formData).length > 0) {
                // 格式化显示表单数据
                addLog('info', '📝 提交的表单数据:');

                Object.entries(formData).forEach(([key, value]) => {
                    let displayValue;
                    if (typeof value === 'object') {
                        displayValue = JSON.stringify(value, null, 2);
                    } else {
                        displayValue = String(value);
                    }
                    addLog('info', `   ${key}: ${displayValue}`);
                });
            }
        }

        // WebSocket 连接管理 - 增强版本
        let wsConnection = null;
        let currentThreadId = null;
        let heartbeatInterval = null;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectDelay = 1000; // 初始重连延迟1秒

        // 连接状态管理 - 增强版本
        function updateConnectionStatus(status, text) {
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.querySelector('.status-text');

            if (statusDot && statusText) {
                // 移除所有状态类
                statusDot.className = 'status-dot';
                statusDot.classList.add(status);
                statusText.textContent = text;

                // 根据状态添加不同的视觉效果
                if (status === 'connected') {
                    statusDot.style.animation = 'pulse 2s infinite';
                } else if (status === 'connecting') {
                    statusDot.style.animation = 'spin 1s linear infinite';
                } else {
                    statusDot.style.animation = 'none';
                }
            }
        }

        // WebSocket心跳检测
        function startHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
            }

            heartbeatInterval = setInterval(() => {
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    wsConnection.send(JSON.stringify({
                        type: 'ping',
                        timestamp: new Date().toISOString()
                    }));
                }
            }, 30000); // 每30秒发送一次心跳
        }

        // 停止心跳检测
        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }

        // 开始日志轮询 - 使用真实的 WebSocket 连接
        function startLogPolling(threadId) {
            console.log('开始实时日志监听，Thread ID:', threadId);
            currentThreadId = threadId;

            // 建立 WebSocket 连接到工作流引擎
            const wsUrl = `ws://${window.location.host}/api/runs/${threadId}/events`;
            addLog('debug', `连接到 WebSocket: ${wsUrl}`);

            // 更新连接状态为连接中
            updateConnectionStatus('connecting', '连接中...');

            try {
                wsConnection = new WebSocket(wsUrl);

                wsConnection.onopen = function(event) {
                    addLog('success', '✅ 实时日志连接已建立');
                    updateConnectionStatus('connected', '已连接');
                    console.log('WebSocket 连接已建立:', event);

                    // 启动心跳检测
                    startHeartbeat();

                    // 连接建立后立即请求当前状态
                    if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                        wsConnection.send(JSON.stringify({
                            type: 'status_request',
                            timestamp: new Date().toISOString()
                        }));
                    }
                };

                wsConnection.onmessage = function(event) {
                    try {
                        const message = JSON.parse(event.data);
                        console.log('收到 WebSocket 消息:', message);

                        if (message.type === 'log') {
                            // 处理日志消息
                            const logData = message.data;
                            const level = logData.level ? logData.level.toLowerCase() : 'info';
                            const nodeInfo = logData.node_id ? ` [${logData.node_id}]` : '';
                            const logMessage = `${logData.message}${nodeInfo}`;

                            addLog(level, logMessage);
                        } else if (message.type === 'status') {
                            // 处理状态更新消息
                            const statusData = message.data;
                            console.log('收到状态更新:', statusData);

                            if (statusData && statusData.status) {
                                addLog('info', `📊 状态更新: ${getStatusText(statusData.status)}`);
                                updateStatus(statusData.status);

                                // 同时更新按钮状态和计时器
                                if (statusData.status === 'running') {
                                    updateButtonState(true);
                                    if (!timerState.isRunning) {
                                        startTimer();
                                    }
                                } else if (statusData.status === 'paused') {
                                    updateButtonState(false);
                                    if (timerState.isRunning) {
                                        pauseTimer();
                                    }
                                } else if (['stopped', 'completed', 'failed', 'cancelled', 'timeout', 'error'].includes(statusData.status)) {
                                    updateButtonState(false);
                                    if (timerState.isRunning || timerState.isPaused) {
                                        stopTimer();
                                    }
                                } else if (['idle', 'pending'].includes(statusData.status)) {
                                    updateButtonState(false);
                                }
                            }
                        } else if (message.type === 'connection') {
                            addLog('info', `📡 ${message.status}: ${message.thread_id}`);
                        } else if (message.type === 'error') {
                            addLog('error', `❌ 错误: ${message.message}`);
                        } else if (message.type === 'pong') {
                            // 处理心跳响应
                            console.log('收到心跳响应');
                        }
                    } catch (e) {
                        console.error('解析 WebSocket 消息失败:', e, event.data);
                        addLog('warning', `⚠️ 收到无法解析的消息: ${event.data}`);
                    }
                };

                wsConnection.onerror = function(error) {
                    console.error('WebSocket 错误:', error);
                    addLog('error', '❌ 实时日志连接出错');
                    updateConnectionStatus('disconnected', '连接错误');
                    stopHeartbeat();
                };

                wsConnection.onclose = function(event) {
                    console.log('WebSocket 连接已关闭:', event);
                    addLog('warning', '⚠️ 实时日志连接已断开');
                    updateConnectionStatus('disconnected', '已断开');
                    stopHeartbeat();

                    // 如果是非正常关闭且还有活动的thread_id，尝试重连
                    if (event.code !== 1000 && currentThreadId && reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        const delay = Math.min(reconnectDelay * Math.pow(2, reconnectAttempts - 1), 30000); // 指数退避，最大30秒

                        addLog('info', `🔄 尝试重新连接... (${reconnectAttempts}/${maxReconnectAttempts})`);
                        updateConnectionStatus('connecting', '重连中...');

                        setTimeout(() => {
                            if (currentThreadId) {
                                startLogPolling(currentThreadId);
                            }
                        }, delay);
                    } else if (reconnectAttempts >= maxReconnectAttempts) {
                        addLog('error', '❌ 重连次数已达上限，切换到HTTP轮询模式');
                        startHttpLogPolling(currentThreadId);
                    }
                };

            } catch (error) {
                console.error('创建 WebSocket 连接失败:', error);
                addLog('error', `❌ 无法建立实时日志连接: ${error.message}`);

                // 降级到 HTTP 轮询
                startHttpLogPolling(threadId);
            }
        }

        // HTTP 轮询作为 WebSocket 的降级方案
        function startHttpLogPolling(threadId) {
            addLog('info', '🔄 使用 HTTP 轮询获取日志');

            const pollLogs = () => {
                if (!currentThreadId || currentThreadId !== threadId) {
                    return; // 停止轮询
                }

                fetch(`/api/thread/${threadId}/logs`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.logs && data.logs.length > 0) {
                            data.logs.forEach(log => {
                                const level = log.level ? log.level.toLowerCase() : 'info';
                                const nodeInfo = log.node_id ? ` [${log.node_id}]` : '';
                                const logMessage = `${log.message}${nodeInfo}`;
                                addLog(level, logMessage);
                            });
                        }

                        // 检查工作流状态
                        if (data.status) {
                            updateStatus(data.status);

                            // 同时更新按钮状态
                            if (data.status === 'running') {
                                updateButtonState(true);
                            } else if (data.status === 'paused' || data.status === 'stopped' || data.status === 'completed' || data.status === 'failed' || data.status === 'cancelled' || data.status === 'timeout' || data.status === 'error') {
                                updateButtonState(false);
                            }

                            // 如果工作流完成，停止轮询
                            if (data.status === 'completed' || data.status === 'failed') {
                                currentThreadId = null;
                                return;
                            }
                        }

                        // 继续轮询
                        setTimeout(pollLogs, 2000);
                    })
                    .catch(error => {
                        console.error('获取日志失败:', error);
                        addLog('error', `❌ 获取日志失败: ${error.message}`);

                        // 继续轮询，但增加间隔
                        setTimeout(pollLogs, 5000);
                    });
            };

            // 开始轮询
            pollLogs();
        }

        // 停止日志监听
        function stopLogPolling() {
            currentThreadId = null;

            if (wsConnection) {
                wsConnection.close(1000, '用户停止监听');
                wsConnection = null;
                addLog('info', '🛑 已停止实时日志监听');
            }
        }

        // 工作流状态跟踪
        let isWorkflowRunning = false;

        // 计时器状态管理 - 增加 finalTime 支持
        let timerState = {
            startTime: null,
            pausedTime: 0,
            isRunning: false,
            isPaused: false,
            intervalId: null,
            finalTime: undefined  // 保存最终时间，用于任务完成后显示
        };

        // 格式化时间显示 (HH:MM:SS)
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // 更新计时器显示 - 优化版本：支持保持最终时间
        function updateTimerDisplay() {
            const timerDisplay = document.getElementById('timer-display');
            const timerStatus = document.getElementById('timer-status');

            if (!timerDisplay || !timerStatus) return;

            let elapsedSeconds = 0;

            if (timerState.isRunning && timerState.startTime) {
                elapsedSeconds = Math.floor((Date.now() - timerState.startTime - timerState.pausedTime) / 1000);
            } else if (timerState.isPaused && timerState.startTime) {
                elapsedSeconds = Math.floor(timerState.pausedTime / 1000);
            } else if (timerState.finalTime !== undefined) {
                // 如果有最终时间，显示最终时间（任务完成或停止后保持显示）
                elapsedSeconds = timerState.finalTime;
            }

            timerDisplay.textContent = formatTime(Math.max(0, elapsedSeconds));

            // 更新计时器状态显示
            if (timerState.isRunning) {
                timerStatus.textContent = '运行中';
                timerStatus.className = 'timer-status running';
            } else if (timerState.isPaused) {
                timerStatus.textContent = '已暂停';
                timerStatus.className = 'timer-status paused';
            } else if (timerState.finalTime !== undefined && timerState.finalTime > 0) {
                // 显示已完成状态
                timerStatus.textContent = '已完成';
                timerStatus.className = 'timer-status completed';
            } else {
                timerStatus.textContent = '待机';
                timerStatus.className = 'timer-status idle';
            }
        }

        // 启动计时器
        function startTimer() {
            if (timerState.isRunning) return;

            const now = Date.now();

            if (timerState.isPaused) {
                // 从暂停状态恢复
                timerState.pausedTime = now - timerState.startTime - timerState.pausedTime;
                timerState.startTime = now - timerState.pausedTime;
                timerState.isPaused = false;
                addLog('info', '⏯️ 计时器已恢复');
            } else {
                // 全新启动
                timerState.startTime = now;
                timerState.pausedTime = 0;
                addLog('info', '▶️ 计时器已启动');
            }

            timerState.isRunning = true;

            // 启动定时更新
            if (timerState.intervalId) {
                clearInterval(timerState.intervalId);
            }
            timerState.intervalId = setInterval(updateTimerDisplay, 1000);

            updateTimerDisplay();
        }

        // 暂停计时器
        function pauseTimer() {
            if (!timerState.isRunning) return;

            const now = Date.now();
            timerState.pausedTime = now - timerState.startTime - timerState.pausedTime;
            timerState.isRunning = false;
            timerState.isPaused = true;

            if (timerState.intervalId) {
                clearInterval(timerState.intervalId);
                timerState.intervalId = null;
            }

            updateTimerDisplay();
            addLog('info', '⏸️ 计时器已暂停');
        }

        // 停止计时器 - 优化版本：保持最终时间，不重置
        function stopTimer() {
            if (timerState.isRunning || timerState.isPaused) {
                // 计算并保存最终时间
                let finalElapsedSeconds = 0;
                if (timerState.isRunning && timerState.startTime) {
                    finalElapsedSeconds = Math.floor((Date.now() - timerState.startTime - timerState.pausedTime) / 1000);
                } else if (timerState.isPaused && timerState.startTime) {
                    finalElapsedSeconds = Math.floor(timerState.pausedTime / 1000);
                }

                // 保存最终时间到状态中
                timerState.finalTime = Math.max(0, finalElapsedSeconds);

                addLog('info', `⏹️ 计时器已停止，最终时间: ${formatTime(timerState.finalTime)}`);
            }

            timerState.isRunning = false;
            timerState.isPaused = false;
            // 注意：不重置 startTime 和 pausedTime，保持历史记录

            if (timerState.intervalId) {
                clearInterval(timerState.intervalId);
                timerState.intervalId = null;
            }

            updateTimerDisplay();
        }

        // 重置计时器
        function resetTimer() {
            stopTimer();
            const timerDisplay = document.getElementById('timer-display');
            if (timerDisplay) {
                timerDisplay.textContent = '00:00:00';
            }
            addLog('info', '🔄 计时器已重置');
        }

        // 动态切换开始/暂停按钮
        function toggleStartPause() {
            if (!isWorkflowRunning) {
                // 当前是"开始任务"状态，执行启动
                startWorkflow();
            } else {
                // 当前是"暂停任务"状态，执行暂停
                pauseWorkflow();
            }
        }

        // 更新按钮状态 - 增强版本，防止闪烁
        function updateButtonState(isRunning) {
            const button = document.getElementById('start-pause-btn');

            if (button && isWorkflowRunning !== isRunning) {
                isWorkflowRunning = isRunning;

                // 添加过渡效果
                button.style.opacity = '0.7';

                setTimeout(() => {
                    if (isRunning) {
                        button.textContent = '暂停任务';
                        button.className = 'btn btn-warning';
                    } else {
                        button.textContent = '开始任务';
                        button.className = 'btn btn-success';
                    }
                    button.style.opacity = '1';
                }, 150);
            }
        }

        // 启动流程 (保持向后兼容)
        function startFlow() {
            startWorkflow();
        }

        // 暂停工作流
        function pauseWorkflow() {
            console.log('暂停流程:', flowName);

            if (currentThreadId) {
                const flowId = "{{ flow_id }}";
                const apiUrl = `/api/thread/${currentThreadId}/pause`;

                fetch(apiUrl, { method: 'POST' })
                    .then(response => {
                        if (response.ok) {
                            return response.json();
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    })
                    .then(data => {
                        // 后端返回 ThreadControlResponse: {thread_id, status, message}
                        if (data.status === 'pause_requested') {
                            addLog('warning', '⏸️ 工作流已暂停');
                            updateStatus('paused');
                            updateButtonState(false); // 切换回"开始任务"状态
                            pauseTimer(); // 暂停计时器
                        } else {
                            addLog('error', `❌ 暂停失败: ${data.message || '未知错误'}`);
                        }
                    })
                    .catch(error => {
                        addLog('error', `❌ 暂停请求失败: ${error.message}`);
                    });
            } else {
                addLog('warning', '⚠️ 没有正在运行的工作流');
                updateButtonState(false); // 确保按钮状态正确
            }
        }

        // 保持向后兼容的暂停函数
        function pauseFlow() {
            pauseWorkflow();
        }

        // 停止流程
        function stopFlow() {
            console.log('停止流程:', flowName);

            if (currentThreadId) {
                const flowId = "{{ flow_id }}";
                const apiUrl = `/api/thread/${currentThreadId}/stop`;

                fetch(apiUrl, { method: 'POST' })
                    .then(response => {
                        if (response.ok) {
                            return response.json();
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    })
                    .then(data => {
                        // 后端返回 ThreadControlResponse: {thread_id, status, message}
                        if (data.status === 'stopped') {
                            addLog('warning', '🛑 工作流已停止');
                            updateStatus('stopped');
                            updateButtonState(false); // 重置为"开始任务"状态
                            stopTimer(); // 停止计时器
                            stopLogPolling(); // 停止日志监听
                        } else {
                            addLog('error', `❌ 停止失败: ${data.message || '未知错误'}`);
                        }
                    })
                    .catch(error => {
                        addLog('error', `❌ 停止请求失败: ${error.message}`);
                    });
            } else {
                addLog('warning', '⚠️ 没有正在运行的工作流');
                stopLogPolling(); // 即使没有运行的工作流，也停止日志监听
            }
        }



        // 更新状态 - 优化版本：适配新的布局结构
        function updateStatus(status) {
            const statusInfo = document.getElementById('status-info');

            // 更新状态显示
            if (statusInfo) {
                statusInfo.textContent = getStatusText(status);
                statusInfo.className = `status-display ${status}`;
            }

            // 根据状态更新计时器状态
            if (['completed', 'stopped', 'failed', 'cancelled', 'timeout', 'error'].includes(status)) {
                // 任务结束状态：停止计时器但保持最终时间
                if (timerState.isRunning || timerState.isPaused) {
                    stopTimer();
                }

                // 更新计时器状态文本以反映任务结束
                const timerStatus = document.getElementById('timer-status');
                if (timerStatus && timerState.finalTime !== undefined && timerState.finalTime > 0) {
                    if (status === 'completed') {
                        timerStatus.textContent = '已完成';
                        timerStatus.className = 'timer-status completed';
                    } else {
                        timerStatus.textContent = '已停止';
                        timerStatus.className = 'timer-status stopped';
                    }
                }
            }
        }

        // 获取状态文本
        function getStatusText(status) {
            const statusMap = {
                'idle': '空闲',
                'pending': '等待中',
                'running': '运行中',
                'paused': '已暂停',
                'stopped': '已停止',
                'completed': '已完成',
                'failed': '失败',
                'error': '错误',
                'cancelled': '已取消',
                'timeout': '超时'
            };
            return statusMap[status] || status;
        }

        // 加载日志
        function loadLogs() {
            const container = document.getElementById('logs-container');
            const logs = [
                { time: '2025-10-22 17:18:00', level: 'INFO', message: `流程 ${flowName} 初始化完成` },
                { time: '2025-10-22 17:18:01', level: 'INFO', message: '等待触发执行...' }
            ];

            let html = '';
            logs.forEach(log => {
                const logClass = `log-${log.level.toLowerCase()}`;
                html += `<div class="log-entry ${logClass}">[${log.time}] [${log.level}] ${log.message}</div>`;
            });

            container.innerHTML = html || '<p style="color: #9E9E9E;">暂无日志记录</p>';
        }

        // 添加日志
        function addLog(level, message) {
            const container = document.getElementById('logs-container');
            const now = new Date().toLocaleString();

            // 创建带颜色的日志条目
            const logClass = `log-${level.toLowerCase()}`;
            const logEntry = `<div class="log-entry ${logClass}">[${now}] [${level.toUpperCase()}] ${message}</div>`;

            if (container.innerHTML.includes('暂无日志记录')) {
                container.innerHTML = logEntry;
            } else {
                container.innerHTML += logEntry;
            }

            // 自动滚动到底部
            container.scrollTop = container.scrollHeight;
        }

        // 清空日志
        function clearLogs() {
            document.getElementById('logs-container').innerHTML = '<p style="color: #9E9E9E;">暂无日志记录</p>';
        }

        // 刷新状态
        function refreshStatus() {
            if (currentThreadId) {
                addLog('info', '🔄 手动刷新状态...');

                fetch(`/api/thread/${currentThreadId}/status`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status) {
                            console.log('手动刷新获取状态:', data.status);
                            addLog('info', `📊 当前状态: ${getStatusText(data.status)}`);
                            updateStatus(data.status);

                            // 更新按钮状态
                            if (data.status === 'running') {
                                updateButtonState(true);
                            } else {
                                updateButtonState(false);
                            }
                        } else {
                            addLog('warning', '⚠️ 无法获取状态信息');
                        }
                    })
                    .catch(error => {
                        console.error('刷新状态失败:', error);
                        addLog('error', `❌ 刷新状态失败: ${error.message}`);
                    });
            } else {
                addLog('warning', '⚠️ 没有活动的工作流');
                updateStatus('idle');
                updateButtonState(false);
            }
        }

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('流程控制台初始化完成:', flowContext);
            addLog('info', `流程控制台已加载: ${appName}/${flowName}`);

            // 初始化连接状态
            updateConnectionStatus('disconnected', '未连接');

            // 初始化计时器显示
            updateTimerDisplay();

            // 检查是否有待处理的thread_id
            const urlParams = new URLSearchParams(window.location.search);
            const pendingThreadId = urlParams.get('thread_id');
            if (pendingThreadId) {
                addLog('info', `检测到待处理的工作流: ${pendingThreadId}`);
                currentThreadId = pendingThreadId;

                // 立即连接WebSocket并获取当前状态
                startLogPolling(pendingThreadId);

                // 同时通过HTTP API获取当前状态作为备份
                refreshStatus();
            } else {
                // 没有thread_id时，显示初始状态
                updateStatus('idle');
                updateButtonState(false);
            }
        });
    </script>
</body>
</html>