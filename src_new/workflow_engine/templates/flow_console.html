<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ren工作流控制台 - {{ app_name }}/{{ flow_name }}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 14px;
        }

        .main-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .control-section {
            padding: 20px;
            border-bottom: 1px solid #ecf0f1;
            background: #f8f9fa;
        }

        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .form-group {
            flex: 1;
            min-width: 300px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #2c3e50;
        }

        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
            min-height: 80px;
        }

        .status-display {
            background: #fff;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            min-width: 250px;
        }

        .status-display h4 {
            margin-bottom: 10px;
            color: #495057;
            font-size: 14px;
        }

        .logs-section {
            padding: 20px;
        }

        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .logs-header h3 {
            color: #2c3e50;
            margin: 0;
        }

        .logs-controls {
            display: flex;
            gap: 10px;
        }

        .logs {
            background: #1e1e1e;
            color: #e0e0e0;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #333;
        }

        .log-entry {
            margin-bottom: 2px;
            padding: 2px 0;
        }

        .log-info { color: #4CAF50; }
        .log-warning { color: #FF9800; }
        .log-error { color: #f44336; }
        .log-debug { color: #9E9E9E; }
        .log-success { color: #8BC34A; }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-block;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #218838, #1ea080);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107, #fd7e14);
            color: #212529;
        }

        .btn-warning:hover {
            background: linear-gradient(135deg, #e0a800, #e8590c);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545, #e83e8c);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #c82333, #d91a72);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-idle {
            background: #e9ecef;
            color: #495057;
        }

        .status-running {
            background: #d4edda;
            color: #155724;
        }

        .status-paused {
            background: #fff3cd;
            color: #856404;
        }

        .status-stopped {
            background: #f8d7da;
            color: #721c24;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        .connection-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background: #dc3545;
            animation: none;
        }

        .status-dot.connecting {
            background: #ffc107;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* 执行状态和计时器优化布局 */
        .execution-info {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .execution-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .execution-status {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-value {
            font-size: 16px;
            font-weight: 700;
            padding: 6px 16px;
            border-radius: 8px;
            display: inline-block;
            min-width: 100px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .status-display {
            font-size: 14px;
            font-weight: 600;
            display: inline;
            margin-left: 8px;
        }

        /* 状态颜色样式 */
        .status-display.idle {
            color: #28a745;
        }

        .status-display.running {
            color: #dc3545;
        }

        .status-display.paused {
            color: #ffc107;
        }

        .status-display.completed {
            color: #17a2b8;
        }

        .status-display.failed,
        .status-display.error,
        .status-display.cancelled,
        .status-display.timeout {
            color: #dc3545;
        }

        .status-display.stopped {
            color: #6c757d;
        }

        .status-display.pending {
            color: #17a2b8;
        }

        .execution-connection {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .connection-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .connection-display {
            font-size: 14px;
            font-weight: 600;
            display: inline;
            margin-left: 8px;
            color: #28a745;
        }

        .execution-timer {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .timer-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .timer-display {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .timer-display:hover {
            transform: translateY(-1px);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1), 0 4px 12px rgba(0,0,0,0.15);
        }

        .timer-status {
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .timer-status.running {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border: 1px solid #c3e6cb;
            animation: pulse-green 2s infinite;
        }

        .timer-status.paused {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .timer-status.stopped {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .timer-status.completed {
            background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .timer-status.idle {
            background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
            color: #383d41;
            border: 1px solid #d6d8db;
        }


            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .timer-control-buttons .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .timer-control-buttons .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .timer-control-buttons .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .timer-control-buttons .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #212529;
        }

        .timer-control-buttons .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #e83e8c 100%);
            color: white;
        }

        .timer-control-buttons .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
        }

        @keyframes pulse-green {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        /* 状态指示器样式优化 */
        .status.status-running {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
        }

        .status.status-paused {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #212529;
            box-shadow: 0 2px 4px rgba(255, 193, 7, 0.3);
        }

        .status.status-completed {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(23, 162, 184, 0.3);
        }

        .status.status-stopped {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);
        }

        .status.status-failed {
            background: linear-gradient(135deg, #dc3545 0%, #bd2130 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);
        }

        .status.status-idle {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(108, 117, 125, 0.3);
        }

        .execution-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: #6c757d;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e9ecef;
        }

        .last-update {
            font-style: italic;
            font-weight: 500;
        }

        /* 响应式优化 */
        @media (max-width: 768px) {
            .execution-header {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }

            .execution-timer {
                align-items: center;
            }

            .timer-display {
                font-size: 28px;
                min-width: 140px;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            .header-right {
                text-align: center;
            }

            .header-right .status-display {
                min-width: auto;
                width: 100%;
            }

            .control-row {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                justify-content: center;
            }

            .logs-header {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .logs-controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1>工作流控制台</h1>
                <p>应用: {{ app_name }} | 流程: {{ flow_name }} | 版本: {{ version_info }}</p>
            </div>
            <div class="header-right">
                <div class="execution-info">
                    <div class="execution-header">
                        <div class="execution-status">
                            <span class="status-label">执行状态：<span id="status-info" class="status-display">空闲</span></span>
                        </div>
                        <div class="execution-timer">
                            <span class="timer-label">执行时间：<span id="timer-display" class="timer-display">00:00:00</span></span>
                        </div>
                        <div class="execution-connection">
                            <span class="connection-label">连接状态：<span id="connection-status" class="connection-display">已连接</span></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <!-- 工作流控制区域 -->
            <div class="control-section">
                <div class="control-row">
                    <div class="control-group">
                        <button id="start-pause-btn" class="btn btn-success" onclick="toggleStartPause()">开始任务</button>
                        <button class="btn btn-danger" onclick="stopFlow()">停止流程</button>
                    </div>
                </div>



            </div>

            <!-- 执行日志区域 -->
            <div class="logs-section">
                <div class="logs-header">
                    <h3>执行日志</h3>
                    <div class="logs-controls">
                        <button class="btn btn-secondary" onclick="loadLogs()">刷新日志</button>
                        <button class="btn btn-secondary" onclick="clearLogs()">清空日志</button>
                    </div>
                </div>
                <div id="logs-container" class="logs">
                    <p>暂无日志记录</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 流程上下文
        const flowContext = {{ flow_context | tojson }};
        const appName = "{{ app_name }}";
        const flowName = "{{ flow_name }}";

        // 启动工作流 (新的主要启动函数，智能处理thread_id)
        function startWorkflow() {
            console.log('启动工作流:', flowName);
            addLog('info', '正在启动工作流...');

            const flowId = "{{ flow_id }}";
            const apiUrl = `/api/flows/${flowId}/start/latest`;
            addLog('debug', `调用API: ${apiUrl}`);

            // 智能处理thread_id：只在首次启动或从表单提交页面跳转时使用URL中的thread_id
            const urlParams = new URLSearchParams(window.location.search);
            let pendingThreadId = null;

            // 只有在以下情况下才使用URL中的thread_id：
            // 1. 当前没有活动的工作流（首次启动）
            // 2. 从表单提交页面跳转过来（form_data=submitted）
            // 3. 当前工作流状态为idle或pending
            if ((!currentThreadId || ['idle', 'pending'].includes(currentWorkflowStatus)) &&
                (urlParams.get('form_data') === 'submitted' || !currentThreadId)) {
                pendingThreadId = urlParams.get('thread_id') || null;
                addLog('debug', `使用URL中的thread_id: ${pendingThreadId}`);
            } else {
                // 重新启动时不使用旧的thread_id，让服务器生成新的
                addLog('debug', '重新启动工作流，将生成新的thread_id');
            }

            // 调用后端API启动工作流
            fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    input_data: {},
                    thread_id: pendingThreadId
                })
            })
            .then(async response => {
                addLog('debug', `API响应状态: ${response.status}`);
                const data = await response.json();

                if (!response.ok) {
                    const errorMsg = data.detail || data.message || `HTTP ${response.status} 错误`;
                    throw new Error(errorMsg);
                }
                return data;
            })
            .then(data => {
                console.log('API响应数据:', data);

                if (data.thread_id) {
                    addLog('success', `✅ 工作流启动成功！Thread ID: ${data.thread_id}`);
                    updateStatus('running');
                    updateButtonState(true); // 切换到"暂停任务"状态

                    // 启动计时器 - 与任务状态同步
                    startTimer();
                    addLog('info', '⏱️ 计时器已启动');

                    addLog('info', `📋 流程ID: ${data.flow_id}`);
                    addLog('info', `📋 版本: ${data.version}`);
                    addLog('info', `📋 状态: ${data.status}`);

                    if (data.inputs && Object.keys(data.inputs).length > 0) {
                        addLog('info', '📝 输入数据:');
                        displayInputData(data.inputs);
                    }

                    if (urlParams.get('form_data') === 'submitted') {
                        displayFormData(data.inputs || {});
                    }

                    startLogPolling(data.thread_id);
                } else {
                    const errorMsg = data.detail || data.message || '未知错误';
                    addLog('error', `❌ 启动失败: ${errorMsg}`);
                    console.error('启动失败详情:', data);
                }
            })
            .catch(error => {
                console.error('启动工作流失败:', error);
                addLog('error', `❌ 启动失败: ${error.message}`);

                if (error.message.includes('404')) {
                    addLog('warning', '💡 提示: 请检查流程ID是否正确，或流程是否已发布');
                } else if (error.message.includes('500')) {
                    addLog('warning', '💡 提示: 服务器内部错误，请检查工作流定义或联系管理员');
                } else if (error.message.includes('400')) {
                    addLog('warning', '💡 提示: 请求参数错误，可能是thread_id冲突');
                    addLog('info', '🔧 解决方案: 正在清理状态并重试...');

                    // 清理所有状态和URL参数，然后重试
                    currentThreadId = null;
                    pausedThreadId = null;
                    currentWorkflowStatus = 'idle';

                    // 清理URL参数
                    const url = new URL(window.location);
                    if (url.searchParams.has('thread_id')) {
                        url.searchParams.delete('thread_id');
                        window.history.replaceState({}, '', url);
                        addLog('debug', '已清理URL中的thread_id参数');
                    }

                    addLog('info', '✅ 状态已清理，请重新点击"开始任务"按钮');
                } else {
                    addLog('warning', '💡 提示: 未知错误，请检查网络连接或联系管理员');
                }
            });
        }

        // 显示输入数据（格式化到日志中）
        function displayInputData(inputData) {
            Object.entries(inputData).forEach(([key, value]) => {
                let displayValue;
                if (typeof value === 'object') {
                    displayValue = JSON.stringify(value, null, 2);
                } else {
                    displayValue = String(value);
                }
                addLog('info', `   ${key}: ${displayValue}`);
            });
        }

        // 显示表单数据
        function displayFormData(formData) {
            if (Object.keys(formData).length > 0) {
                // 格式化显示表单数据
                addLog('info', '📝 提交的表单数据:');

                Object.entries(formData).forEach(([key, value]) => {
                    let displayValue;
                    if (typeof value === 'object') {
                        displayValue = JSON.stringify(value, null, 2);
                    } else {
                        displayValue = String(value);
                    }
                    addLog('info', `   ${key}: ${displayValue}`);
                });
            }
        }

        // WebSocket 连接管理 - 增强版本
        let wsConnection = null;
        let currentThreadId = null;
        let heartbeatInterval = null;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectDelay = 1000; // 初始重连延迟1秒

        // 连接状态管理 - 增强版本
        function updateConnectionStatus(status, text) {
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.querySelector('.status-text');

            if (statusDot && statusText) {
                // 移除所有状态类
                statusDot.className = 'status-dot';
                statusDot.classList.add(status);
                statusText.textContent = text;

                // 根据状态添加不同的视觉效果
                if (status === 'connected') {
                    statusDot.style.animation = 'pulse 2s infinite';
                } else if (status === 'connecting') {
                    statusDot.style.animation = 'spin 1s linear infinite';
                } else {
                    statusDot.style.animation = 'none';
                }
            }
        }

        // WebSocket心跳检测
        function startHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
            }

            heartbeatInterval = setInterval(() => {
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    wsConnection.send(JSON.stringify({
                        type: 'ping',
                        timestamp: new Date().toISOString()
                    }));
                }
            }, 30000); // 每30秒发送一次心跳
        }

        // 停止心跳检测
        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }

        // 开始日志轮询 - 使用真实的 WebSocket 连接
        function startLogPolling(threadId) {
            console.log('开始实时日志监听，Thread ID:', threadId);
            currentThreadId = threadId;

            // 建立 WebSocket 连接到工作流引擎
            const wsUrl = `ws://${window.location.host}/api/runs/${threadId}/events`;
            addLog('debug', `连接到 WebSocket: ${wsUrl}`);

            // 更新连接状态为连接中
            updateConnectionStatus('connecting', '连接中...');

            try {
                wsConnection = new WebSocket(wsUrl);

                wsConnection.onopen = function(event) {
                    addLog('success', '✅ 实时日志连接已建立');
                    updateConnectionStatus('connected', '已连接');
                    console.log('WebSocket 连接已建立:', event);

                    // 启动心跳检测
                    startHeartbeat();

                    // 连接建立后立即请求当前状态
                    if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                        wsConnection.send(JSON.stringify({
                            type: 'status_request',
                            timestamp: new Date().toISOString()
                        }));
                    }
                };

                wsConnection.onmessage = function(event) {
                    try {
                        const message = JSON.parse(event.data);
                        console.log('收到 WebSocket 消息:', message);

                        if (message.type === 'log') {
                            // 处理日志消息
                            const logData = message.data;
                            const level = logData.level ? logData.level.toLowerCase() : 'info';
                            const nodeInfo = logData.node_id ? ` [${logData.node_id}]` : '';
                            const logMessage = `${logData.message}${nodeInfo}`;

                            addLog(level, logMessage);
                        } else if (message.type === 'status') {
                            // 处理状态更新消息
                            const statusData = message.data;
                            console.log('收到状态更新:', statusData);

                            if (statusData && statusData.status) {
                                addLog('info', `📊 状态更新: ${getStatusText(statusData.status)}`);
                                updateStatus(statusData.status);

                                // 同时更新按钮状态和计时器 - 修复自动启动问题
                                if (statusData.status === 'running') {
                                    updateButtonState(true);
                                    // 移除自动启动计时器 - 只有用户手动点击才启动
                                    // if (!timerState.isRunning) {
                                    //     startTimer();
                                    // }
                                } else if (statusData.status === 'paused') {
                                    updateButtonState(false);
                                    if (timerState.isRunning) {
                                        pauseTimer();
                                    }
                                } else if (['stopped', 'completed', 'failed', 'cancelled', 'timeout', 'error'].includes(statusData.status)) {
                                    updateButtonState(false);
                                    if (timerState.isRunning || timerState.isPaused) {
                                        stopTimer();
                                    }
                                } else if (['idle', 'pending'].includes(statusData.status)) {
                                    updateButtonState(false);
                                }
                            }
                        } else if (message.type === 'connection') {
                            addLog('info', `📡 ${message.status}: ${message.thread_id}`);
                        } else if (message.type === 'error') {
                            addLog('error', `❌ 错误: ${message.message}`);
                        } else if (message.type === 'pong') {
                            // 处理心跳响应
                            console.log('收到心跳响应');
                        }
                    } catch (e) {
                        console.error('解析 WebSocket 消息失败:', e, event.data);
                        addLog('warning', `⚠️ 收到无法解析的消息: ${event.data}`);
                    }
                };

                wsConnection.onerror = function(error) {
                    console.error('WebSocket 错误:', error);
                    addLog('error', '❌ 实时日志连接出错');
                    updateConnectionStatus('disconnected', '连接错误');
                    stopHeartbeat();

                    // WebSocket错误时，如果计时器还在运行，暂停它以避免数据不一致
                    if (timerState.isRunning) {
                        pauseTimer();
                        addLog('warning', '⚠️ 连接中断，计时器已暂停');
                    }
                };

                wsConnection.onclose = function(event) {
                    console.log('WebSocket 连接已关闭:', event);
                    addLog('warning', '⚠️ 实时日志连接已断开');
                    updateConnectionStatus('disconnected', '已断开');
                    stopHeartbeat();

                    // WebSocket连接关闭时，如果计时器还在运行，暂停它以避免数据不一致
                    if (timerState.isRunning) {
                        pauseTimer();
                        addLog('warning', '⚠️ 连接断开，计时器已暂停');
                    }

                    // 如果是非正常关闭且还有活动的thread_id，尝试重连
                    if (event.code !== 1000 && currentThreadId && reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        const delay = Math.min(reconnectDelay * Math.pow(2, reconnectAttempts - 1), 30000); // 指数退避，最大30秒

                        addLog('info', `🔄 尝试重新连接... (${reconnectAttempts}/${maxReconnectAttempts})`);
                        updateConnectionStatus('connecting', '重连中...');

                        setTimeout(() => {
                            if (currentThreadId) {
                                startLogPolling(currentThreadId);
                            }
                        }, delay);
                    } else if (reconnectAttempts >= maxReconnectAttempts) {
                        addLog('error', '❌ 重连次数已达上限，切换到HTTP轮询模式');
                        startHttpLogPolling(currentThreadId);
                    }
                };

            } catch (error) {
                console.error('创建 WebSocket 连接失败:', error);
                addLog('error', `❌ 无法建立实时日志连接: ${error.message}`);

                // 降级到 HTTP 轮询
                startHttpLogPolling(threadId);
            }
        }

        // HTTP 轮询作为 WebSocket 的降级方案
        function startHttpLogPolling(threadId) {
            addLog('info', '🔄 使用 HTTP 轮询获取日志');

            const pollLogs = () => {
                if (!currentThreadId || currentThreadId !== threadId) {
                    return; // 停止轮询
                }

                fetch(`/api/thread/${threadId}/logs`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.logs && data.logs.length > 0) {
                            data.logs.forEach(log => {
                                const level = log.level ? log.level.toLowerCase() : 'info';
                                const nodeInfo = log.node_id ? ` [${log.node_id}]` : '';
                                const logMessage = `${log.message}${nodeInfo}`;
                                addLog(level, logMessage);
                            });
                        }

                        // 检查工作流状态
                        if (data.status) {
                            updateStatus(data.status);

                            // 同时更新按钮状态和计时器状态
                            if (data.status === 'running') {
                                updateButtonState(true);
                                // 如果工作流正在运行但计时器未启动，启动计时器
                                if (!timerState.isRunning && !timerState.isPaused && !timerState.isStopped) {
                                    startTimer();
                                }
                            } else if (data.status === 'paused') {
                                updateButtonState(false);
                                // 如果工作流暂停但计时器还在运行，暂停计时器
                                if (timerState.isRunning) {
                                    pauseTimer();
                                }
                            } else if (['stopped', 'completed', 'failed', 'cancelled', 'timeout', 'error'].includes(data.status)) {
                                updateButtonState(false);
                                // 如果工作流结束但计时器还在运行，停止计时器
                                if (timerState.isRunning || timerState.isPaused) {
                                    stopTimer();
                                }
                            }

                            // 如果工作流完成，停止轮询
                            if (data.status === 'completed' || data.status === 'failed') {
                                currentThreadId = null;
                                return;
                            }
                        }

                        // 继续轮询
                        setTimeout(pollLogs, 2000);
                    })
                    .catch(error => {
                        console.error('获取日志失败:', error);
                        addLog('error', `❌ 获取日志失败: ${error.message}`);

                        // 继续轮询，但增加间隔
                        setTimeout(pollLogs, 5000);
                    });
            };

            // 开始轮询
            pollLogs();
        }

        // 停止日志监听
        function stopLogPolling() {
            currentThreadId = null;

            if (wsConnection) {
                wsConnection.close(1000, '用户停止监听');
                wsConnection = null;
                addLog('info', '🛑 已停止实时日志监听');
            }
        }

        // 工作流状态跟踪
        let isWorkflowRunning = false;

        // 暂停状态管理 - 用于智能恢复逻辑
        let pausedThreadId = null;  // 保存暂停时的线程ID
        let currentWorkflowStatus = 'idle';  // 当前工作流状态

        // 计时器状态管理 - 重新设计，修复所有逻辑问题
        let timerState = {
            startTime: null,
            totalPausedTime: 0,  // 累计暂停时间
            pauseStartTime: null, // 暂停开始时间
            isRunning: false,
            isPaused: false,
            intervalId: null,
            finalTime: undefined,  // 保存最终时间，用于任务完成后显示
            isStopped: false      // 新增：标记是否已完全停止
        };

        // 格式化时间显示 (HH:MM:SS)
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // 更新计时器显示 - 完全重写，修复所有逻辑问题
        function updateTimerDisplay() {
            const timerDisplay = document.getElementById('timer-display');

            if (!timerDisplay) return;

            let elapsedSeconds = 0;

            if (timerState.isStopped && timerState.finalTime !== undefined) {
                // 已停止状态：显示最终时间，不再更新
                elapsedSeconds = timerState.finalTime;
            } else if (timerState.isRunning && timerState.startTime) {
                // 运行状态：当前时间 - 开始时间 - 累计暂停时间
                elapsedSeconds = Math.floor((Date.now() - timerState.startTime - timerState.totalPausedTime) / 1000);
            } else if (timerState.isPaused && timerState.startTime) {
                // 暂停状态：暂停时的累计时间
                const timeBeforePause = timerState.pauseStartTime - timerState.startTime - timerState.totalPausedTime;
                elapsedSeconds = Math.floor(timeBeforePause / 1000);
            }

            timerDisplay.textContent = formatTime(Math.max(0, elapsedSeconds));

            // 计时器状态现在通过执行状态显示，无需单独的状态标签
        }

        // 启动计时器 - 完全重写
        function startTimer() {
            if (timerState.isRunning || timerState.isStopped) return;

            const now = Date.now();

            if (timerState.isPaused && timerState.pauseStartTime) {
                // 从暂停状态恢复：累加本次暂停时间
                timerState.totalPausedTime += (now - timerState.pauseStartTime);
                timerState.isPaused = false;
                timerState.pauseStartTime = null;
                addLog('info', '⏯️ 计时器已恢复');
            } else {
                // 全新启动
                timerState.startTime = now;
                timerState.totalPausedTime = 0;
                timerState.pauseStartTime = null;
                timerState.finalTime = undefined;
                timerState.isStopped = false;
                addLog('info', '▶️ 计时器已启动');
            }

            timerState.isRunning = true;

            // 启动定时更新
            if (timerState.intervalId) {
                clearInterval(timerState.intervalId);
            }
            timerState.intervalId = setInterval(updateTimerDisplay, 1000);

            updateTimerDisplay();
        }

        // 暂停计时器 - 修复逻辑错误
        function pauseTimer() {
            if (!timerState.isRunning || timerState.isStopped) return;

            const now = Date.now();
            timerState.pauseStartTime = now;  // 记录暂停开始时间
            timerState.isRunning = false;
            timerState.isPaused = true;

            if (timerState.intervalId) {
                clearInterval(timerState.intervalId);
                timerState.intervalId = null;
            }

            updateTimerDisplay();
            addLog('info', '⏸️ 计时器已暂停');
        }

        // 停止计时器 - 增强版本，确保完全停止
        function stopTimer() {
            if (timerState.isStopped) return; // 已经停止，避免重复处理

            // 计算并保存最终时间
            let finalElapsedSeconds = 0;
            const now = Date.now();

            if (timerState.isRunning && timerState.startTime) {
                finalElapsedSeconds = Math.floor((now - timerState.startTime - timerState.totalPausedTime) / 1000);
            } else if (timerState.isPaused && timerState.startTime && timerState.pauseStartTime) {
                const timeBeforePause = timerState.pauseStartTime - timerState.startTime - timerState.totalPausedTime;
                finalElapsedSeconds = Math.floor(timeBeforePause / 1000);
            }

            // 保存最终时间并标记为已停止
            timerState.finalTime = Math.max(0, finalElapsedSeconds);
            timerState.isRunning = false;
            timerState.isPaused = false;
            timerState.isStopped = true;

            // 清除定时器
            if (timerState.intervalId) {
                clearInterval(timerState.intervalId);
                timerState.intervalId = null;
            }

            updateTimerDisplay();
            addLog('info', `⏹️ 计时器已停止，最终时间: ${formatTime(timerState.finalTime)}`);
        }

        // 重置计时器 - 增强版本
        function resetTimer() {
            // 清除所有状态
            timerState.startTime = null;
            timerState.totalPausedTime = 0;
            timerState.pauseStartTime = null;
            timerState.isRunning = false;
            timerState.isPaused = false;
            timerState.finalTime = undefined;
            timerState.isStopped = false;

            if (timerState.intervalId) {
                clearInterval(timerState.intervalId);
                timerState.intervalId = null;
            }

            const timerDisplay = document.getElementById('timer-display');
            if (timerDisplay) {
                timerDisplay.textContent = '00:00:00';
            }

            updateTimerDisplay();
            addLog('info', '🔄 计时器已重置');
        }

        // 恢复工作流 - 新增函数
        function resumeWorkflow() {
            console.log('恢复流程:', flowName, 'Thread ID:', pausedThreadId);

            if (!pausedThreadId) {
                addLog('error', '❌ 没有可恢复的工作流');
                return;
            }

            const apiUrl = `/api/thread/${pausedThreadId}/resume`;

            fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    updates: {
                        resume_reason: 'user_requested'
                    }
                })
            })
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                })
                .then(data => {
                    // 后端返回 ThreadControlResponse: {thread_id, status, message}
                    if (data.status === 'resumed') {
                        addLog('success', '▶️ 工作流已恢复');
                        currentThreadId = pausedThreadId; // 恢复当前线程ID
                        pausedThreadId = null; // 清除暂停状态
                        currentWorkflowStatus = 'running';
                        updateStatus('running');
                        updateButtonState(true); // 切换到"暂停任务"状态
                        startTimer(); // 恢复计时器
                        startLogPolling(currentThreadId); // 重新开始日志监听
                        addLog('info', '⏱️ 计时器已恢复');
                    } else {
                        addLog('error', `❌ 恢复失败: ${data.message || '未知错误'}`);
                    }
                })
                .catch(error => {
                    addLog('error', `❌ 恢复请求失败: ${error.message}`);
                });
        }

        // 动态切换开始/暂停按钮 - 重写为智能逻辑
        function toggleStartPause() {
            if (!isWorkflowRunning) {
                // 当前是"开始任务"状态，需要判断是恢复还是新启动
                if (pausedThreadId && currentWorkflowStatus === 'paused') {
                    // 有暂停的工作流，执行恢复
                    addLog('info', '🔄 检测到暂停的工作流，正在恢复...');
                    resumeWorkflow();
                } else {
                    // 没有暂停的工作流或工作流已完成，启动新的工作流
                    if (currentWorkflowStatus === 'completed' || currentWorkflowStatus === 'failed' || currentWorkflowStatus === 'stopped') {
                        addLog('info', '🔄 工作流已结束，正在启动新实例...');
                    }
                    startWorkflow();
                }
            } else {
                // 当前是"暂停任务"状态，执行暂停
                pauseWorkflow();
            }
        }

        // 更新按钮状态 - 增强版本，防止闪烁
        function updateButtonState(isRunning) {
            const button = document.getElementById('start-pause-btn');

            if (button && isWorkflowRunning !== isRunning) {
                isWorkflowRunning = isRunning;

                // 添加过渡效果
                button.style.opacity = '0.7';

                setTimeout(() => {
                    if (isRunning) {
                        button.textContent = '暂停任务';
                        button.className = 'btn btn-warning';
                    } else {
                        button.textContent = '开始任务';
                        button.className = 'btn btn-success';
                    }
                    button.style.opacity = '1';
                }, 150);
            }
        }

        // 启动流程 (保持向后兼容)
        function startFlow() {
            startWorkflow();
        }

        // 暂停工作流
        function pauseWorkflow() {
            console.log('暂停流程:', flowName);

            if (currentThreadId) {
                const flowId = "{{ flow_id }}";
                const apiUrl = `/api/thread/${currentThreadId}/pause`;

                fetch(apiUrl, { method: 'POST' })
                    .then(response => {
                        if (response.ok) {
                            return response.json();
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    })
                    .then(data => {
                        // 后端返回 ThreadControlResponse: {thread_id, status, message}
                        if (data.status === 'pause_requested') {
                            addLog('warning', '⏸️ 工作流已暂停');

                            // 保存暂停状态，用于后续恢复
                            pausedThreadId = currentThreadId;  // 保存暂停的线程ID
                            currentWorkflowStatus = 'paused';  // 更新工作流状态

                            updateStatus('paused');
                            updateButtonState(false); // 切换回"开始任务"状态
                            pauseTimer(); // 暂停计时器（保持时间状态）
                            addLog('info', '⏱️ 计时器已暂停');

                            // 保持currentThreadId用于恢复，但停止日志监听
                            stopLogPolling(); // 停止日志监听
                            addLog('info', '💾 已保存工作流状态，可通过"开始任务"按钮恢复');
                        } else {
                            addLog('error', `❌ 暂停失败: ${data.message || '未知错误'}`);
                        }
                    })
                    .catch(error => {
                        addLog('error', `❌ 暂停请求失败: ${error.message}`);
                    });
            } else {
                addLog('warning', '⚠️ 没有正在运行的工作流');
                updateButtonState(false); // 确保按钮状态正确
            }
        }

        // 保持向后兼容的暂停函数
        function pauseFlow() {
            pauseWorkflow();
        }

        // 停止流程
        function stopFlow() {
            console.log('停止流程:', flowName);

            if (currentThreadId) {
                const flowId = "{{ flow_id }}";
                const apiUrl = `/api/thread/${currentThreadId}/stop`;

                fetch(apiUrl, { method: 'POST' })
                    .then(response => {
                        if (response.ok) {
                            return response.json();
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    })
                    .then(data => {
                        // 后端返回 ThreadControlResponse: {thread_id, status, message}
                        if (data.status === 'stopped') {
                            addLog('warning', '🛑 工作流已停止');
                            updateStatus('stopped');
                            updateButtonState(false); // 重置为"开始任务"状态
                            stopTimer(); // 停止计时器
                            stopLogPolling(); // 停止日志监听

                            // 清理所有状态，确保下次启动时使用全新的thread_id
                            currentThreadId = null;
                            pausedThreadId = null;
                            currentWorkflowStatus = 'stopped';
                            addLog('info', '🔄 已清理工作流状态，下次启动将创建新实例');

                            // 清理URL参数中的thread_id，避免重新启动时使用无效的thread_id
                            const url = new URL(window.location);
                            if (url.searchParams.has('thread_id')) {
                                url.searchParams.delete('thread_id');
                                window.history.replaceState({}, '', url);
                                addLog('debug', '已清理URL中的thread_id参数');
                            }
                        } else {
                            addLog('error', `❌ 停止失败: ${data.message || '未知错误'}`);
                        }
                    })
                    .catch(error => {
                        addLog('error', `❌ 停止请求失败: ${error.message}`);
                    });
            } else {
                addLog('warning', '⚠️ 没有正在运行的工作流');
                stopLogPolling(); // 即使没有运行的工作流，也停止日志监听
            }
        }



        // 更新状态 - 优化版本：适配新的布局结构和智能暂停/恢复逻辑
        function updateStatus(status) {
            const statusInfo = document.getElementById('status-info');

            // 更新全局状态变量
            currentWorkflowStatus = status;

            // 更新状态显示
            if (statusInfo) {
                statusInfo.textContent = getStatusText(status);
                statusInfo.className = `status-display ${status}`;
            }

            // 根据状态更新计时器状态和暂停状态管理
            if (['completed', 'stopped', 'failed', 'cancelled', 'timeout', 'error'].includes(status)) {
                // 任务结束状态：停止计时器但保持最终时间
                if (timerState.isRunning || timerState.isPaused) {
                    stopTimer();
                }

                // 清除暂停状态，因为工作流已结束
                if (pausedThreadId) {
                    pausedThreadId = null;
                    addLog('info', '🔄 工作流已结束，清除暂停状态');
                }

                // 计时器状态现在通过执行状态显示，无需单独更新
            } else if (status === 'paused') {
                // 暂停状态：确保计时器也暂停
                if (timerState.isRunning) {
                    pauseTimer();
                }
            } else if (status === 'running') {
                // 运行状态：确保计时器也运行
                if (!timerState.isRunning && !timerState.isStopped) {
                    startTimer();
                }
            }
        }

        // 获取状态文本
        function getStatusText(status) {
            const statusMap = {
                'idle': '空闲',
                'pending': '等待中',
                'running': '运行中',
                'paused': '已暂停',
                'stopped': '已停止',
                'completed': '已完成',
                'failed': '失败',
                'error': '错误',
                'cancelled': '已取消',
                'timeout': '超时'
            };
            return statusMap[status] || status;
        }

        // 加载日志
        function loadLogs() {
            const container = document.getElementById('logs-container');
            const logs = [
                { time: '2025-10-22 17:18:00', level: 'INFO', message: `流程 ${flowName} 初始化完成` },
                { time: '2025-10-22 17:18:01', level: 'INFO', message: '等待触发执行...' }
            ];

            let html = '';
            logs.forEach(log => {
                const logClass = `log-${log.level.toLowerCase()}`;
                html += `<div class="log-entry ${logClass}">[${log.time}] [${log.level}] ${log.message}</div>`;
            });

            container.innerHTML = html || '<p style="color: #9E9E9E;">暂无日志记录</p>';
        }

        // 添加日志
        function addLog(level, message) {
            const container = document.getElementById('logs-container');
            const now = new Date().toLocaleString();

            // 创建带颜色的日志条目
            const logClass = `log-${level.toLowerCase()}`;
            const logEntry = `<div class="log-entry ${logClass}">[${now}] [${level.toUpperCase()}] ${message}</div>`;

            if (container.innerHTML.includes('暂无日志记录')) {
                container.innerHTML = logEntry;
            } else {
                container.innerHTML += logEntry;
            }

            // 自动滚动到底部
            container.scrollTop = container.scrollHeight;
        }

        // 清空日志
        function clearLogs() {
            document.getElementById('logs-container').innerHTML = '<p style="color: #9E9E9E;">暂无日志记录</p>';
        }

        // 刷新状态
        function refreshStatus() {
            if (currentThreadId) {
                addLog('info', '🔄 手动刷新状态...');

                fetch(`/api/thread/${currentThreadId}/status`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status) {
                            console.log('手动刷新获取状态:', data.status);
                            addLog('info', `📊 当前状态: ${getStatusText(data.status)}`);
                            updateStatus(data.status);

                            // 更新按钮状态
                            if (data.status === 'running') {
                                updateButtonState(true);
                            } else {
                                updateButtonState(false);
                            }
                        } else {
                            addLog('warning', '⚠️ 无法获取状态信息');
                        }
                    })
                    .catch(error => {
                        console.error('刷新状态失败:', error);
                        addLog('error', `❌ 刷新状态失败: ${error.message}`);
                    });
            } else {
                addLog('warning', '⚠️ 没有活动的工作流');
                updateStatus('idle');
                updateButtonState(false);
            }
        }

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('流程控制台初始化完成:', flowContext);
            addLog('info', `流程控制台已加载: ${appName}/${flowName}`);

            // 初始化连接状态
            updateConnectionStatus('disconnected', '未连接');

            // 初始化计时器显示
            updateTimerDisplay();

            // 检查是否有待处理的thread_id
            const urlParams = new URLSearchParams(window.location.search);
            const pendingThreadId = urlParams.get('thread_id');
            if (pendingThreadId) {
                addLog('info', `检测到待处理的工作流: ${pendingThreadId}`);
                currentThreadId = pendingThreadId;

                // 立即连接WebSocket并获取当前状态
                startLogPolling(pendingThreadId);

                // 同时通过HTTP API获取当前状态作为备份
                refreshStatus();
            } else {
                // 没有thread_id时，显示初始状态
                updateStatus('idle');
                updateButtonState(false);
            }
        });

        // 页面卸载时的清理处理 - 确保计时器状态正确保存
        window.addEventListener('beforeunload', function(event) {
            // 如果计时器正在运行，暂停它以保存当前状态
            if (timerState.isRunning) {
                pauseTimer();
                addLog('info', '🔄 页面卸载，计时器已暂停保存状态');
            }

            // 关闭WebSocket连接
            if (wsConnection) {
                wsConnection.close(1000, '页面卸载');
            }
        });

        // 页面隐藏时暂停计时器，页面显示时恢复（处理浏览器标签页切换）
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                // 页面隐藏时，如果计时器在运行且有活动工作流，暂停计时器
                if (timerState.isRunning && currentThreadId) {
                    pauseTimer();
                    addLog('info', '👁️ 页面隐藏，计时器已暂停');
                }
            } else {
                // 页面显示时，如果有活动工作流且计时器是暂停状态，检查工作流状态决定是否恢复
                if (timerState.isPaused && currentThreadId) {
                    // 刷新状态以确保与服务器同步
                    refreshStatus();
                    addLog('info', '👁️ 页面显示，正在同步状态...');
                }
            }
        });
    </script>
</body>
</html>