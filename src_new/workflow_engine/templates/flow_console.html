<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å·¥ä½œæµæ§åˆ¶å° - {{ app_name }}/{{ flow_name }}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 14px;
        }

        .main-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .control-section {
            padding: 20px;
            border-bottom: 1px solid #ecf0f1;
            background: #f8f9fa;
        }

        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .form-group {
            flex: 1;
            min-width: 300px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #2c3e50;
        }

        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
            min-height: 80px;
        }

        .status-display {
            background: #fff;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            min-width: 250px;
        }

        .status-display h4 {
            margin-bottom: 10px;
            color: #495057;
            font-size: 14px;
        }

        .logs-section {
            padding: 20px;
        }

        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .logs-header h3 {
            color: #2c3e50;
            margin: 0;
        }

        .logs-controls {
            display: flex;
            gap: 10px;
        }

        .logs {
            background: #1e1e1e;
            color: #e0e0e0;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #333;
        }

        .log-entry {
            margin-bottom: 2px;
            padding: 2px 0;
        }

        .log-info { color: #4CAF50; }
        .log-warning { color: #FF9800; }
        .log-error { color: #f44336; }
        .log-debug { color: #9E9E9E; }
        .log-success { color: #8BC34A; }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-block;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #218838, #1ea080);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107, #fd7e14);
            color: #212529;
        }

        .btn-warning:hover {
            background: linear-gradient(135deg, #e0a800, #e8590c);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545, #e83e8c);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #c82333, #d91a72);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-idle {
            background: #e9ecef;
            color: #495057;
        }

        .status-running {
            background: #d4edda;
            color: #155724;
        }

        .status-paused {
            background: #fff3cd;
            color: #856404;
        }

        .status-stopped {
            background: #f8d7da;
            color: #721c24;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        .connection-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background: #dc3545;
            animation: none;
        }

        .status-dot.connecting {
            background: #ffc107;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* æ‰§è¡ŒçŠ¶æ€å’Œè®¡æ—¶å™¨ä¼˜åŒ–å¸ƒå±€ */
        .execution-info {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .execution-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .execution-status {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-value {
            font-size: 16px;
            font-weight: 700;
            padding: 6px 16px;
            border-radius: 8px;
            display: inline-block;
            min-width: 100px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .status-display {
            font-size: 14px;
            font-weight: 600;
            display: inline;
            margin-left: 8px;
        }

        /* çŠ¶æ€é¢œè‰²æ ·å¼ */
        .status-display.idle {
            color: #28a745;
        }

        .status-display.running {
            color: #dc3545;
        }

        .status-display.paused {
            color: #ffc107;
        }

        .status-display.completed {
            color: #17a2b8;
        }

        .status-display.failed,
        .status-display.error,
        .status-display.cancelled,
        .status-display.timeout {
            color: #dc3545;
        }

        .status-display.stopped {
            color: #6c757d;
        }

        .status-display.pending {
            color: #17a2b8;
        }

        .execution-connection {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .connection-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .connection-display {
            font-size: 14px;
            font-weight: 600;
            display: inline;
            margin-left: 8px;
            color: #28a745;
        }

        .execution-timer {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .timer-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .timer-display {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .timer-display:hover {
            transform: translateY(-1px);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1), 0 4px 12px rgba(0,0,0,0.15);
        }

        .timer-status {
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .timer-status.running {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border: 1px solid #c3e6cb;
            animation: pulse-green 2s infinite;
        }

        .timer-status.paused {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .timer-status.stopped {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .timer-status.completed {
            background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .timer-status.idle {
            background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
            color: #383d41;
            border: 1px solid #d6d8db;
        }

        @keyframes pulse-green {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨æ ·å¼ä¼˜åŒ– */
        .status.status-running {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
        }

        .status.status-paused {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #212529;
            box-shadow: 0 2px 4px rgba(255, 193, 7, 0.3);
        }

        .status.status-completed {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(23, 162, 184, 0.3);
        }

        .status.status-stopped {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);
        }

        .status.status-failed {
            background: linear-gradient(135deg, #dc3545 0%, #bd2130 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);
        }

        .status.status-idle {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(108, 117, 125, 0.3);
        }

        .execution-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: #6c757d;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e9ecef;
        }

        .last-update {
            font-style: italic;
            font-weight: 500;
        }

        /* å“åº”å¼ä¼˜åŒ– */
        @media (max-width: 768px) {
            .execution-header {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }

            .execution-timer {
                align-items: center;
            }

            .timer-display {
                font-size: 28px;
                min-width: 140px;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            .header-right {
                text-align: center;
            }

            .header-right .status-display {
                min-width: auto;
                width: 100%;
            }

            .control-row {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                justify-content: center;
            }

            .logs-header {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .logs-controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1>å·¥ä½œæµæ§åˆ¶å°</h1>
                <p>åº”ç”¨: {{ app_name }} | æµç¨‹: {{ flow_name }} | ç‰ˆæœ¬: {{ version_info }}</p>
            </div>
            <div class="header-right">
                <div class="execution-info">
                    <div class="execution-header">
                        <div class="execution-status">
                            <span class="status-label">æ‰§è¡ŒçŠ¶æ€ï¼š<span id="status-info" class="status-display">ç©ºé—²</span></span>
                        </div>
                        <div class="execution-timer">
                            <span class="timer-label">æ‰§è¡Œæ—¶é—´ï¼š<span id="timer-display" class="timer-display">00:00:00</span></span>
                        </div>
                        <div class="execution-connection">
                            <span class="connection-label">è¿æ¥çŠ¶æ€ï¼š<span id="connection-status" class="connection-display">å·²è¿æ¥</span></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <!-- å·¥ä½œæµæ§åˆ¶åŒºåŸŸ -->
            <div class="control-section">
                <div class="control-row">
                    <div class="control-group">
                        <button id="start-pause-btn" class="btn btn-success" onclick="toggleStartPause()">å¼€å§‹ä»»åŠ¡</button>
                        <button class="btn btn-danger" onclick="stopFlow()">åœæ­¢æµç¨‹</button>
                    </div>
                </div>

            </div>

            <!-- æ‰§è¡Œæ—¥å¿—åŒºåŸŸ -->
            <div class="logs-section">
                <div class="logs-header">
                    <h3>æ‰§è¡Œæ—¥å¿—</h3>
                    <div class="logs-controls">
                        <button class="btn btn-secondary" onclick="loadLogs()">åˆ·æ–°æ—¥å¿—</button>
                        <button class="btn btn-secondary" onclick="clearLogs()">æ¸…ç©ºæ—¥å¿—</button>
                        <button class="btn btn-primary" onclick="refreshStatus()">åˆ·æ–°çŠ¶æ€</button>
                    </div>
                </div>
                <div id="logs-container" class="logs">
                    <p>æš‚æ— æ—¥å¿—è®°å½•</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æµç¨‹ä¸Šä¸‹æ–‡
        const flowContext = {{ flow_context | tojson }};
        const appName = "{{ app_name }}";
        const flowName = "{{ flow_name }}";

        // å¯åŠ¨å·¥ä½œæµ (æ–°çš„ä¸»è¦å¯åŠ¨å‡½æ•°ï¼Œæºå¸¦æäº¤é˜¶æ®µç”Ÿæˆçš„ thread_id)
        function startWorkflow() {
            console.log('å¯åŠ¨å·¥ä½œæµ:', flowName);
            addLog('info', 'æ­£åœ¨å¯åŠ¨å·¥ä½œæµ...');

            const flowId = "{{ flow_id }}";
            const apiUrl = `/api/flows/${flowId}/start/latest`;
            addLog('debug', `è°ƒç”¨API: ${apiUrl}`);

            // ä»URLè·å–æäº¤é˜¶æ®µç”Ÿæˆçš„thread_id
            const urlParams = new URLSearchParams(window.location.search);
            const pendingThreadId = urlParams.get('thread_id') || null;

            // è°ƒç”¨åç«¯APIå¯åŠ¨å·¥ä½œæµï¼ˆå¦‚æœå­˜åœ¨pendingThreadIdåˆ™å¤ç”¨ï¼‰
            fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    input_data: {},
                    thread_id: pendingThreadId
                })
            })
            .then(async response => {
                addLog('debug', `APIå“åº”çŠ¶æ€: ${response.status}`);
                const data = await response.json();

                if (!response.ok) {
                    const errorMsg = data.detail || data.message || `HTTP ${response.status} é”™è¯¯`;
                    throw new Error(errorMsg);
                }
                return data;
            })
            .then(data => {
                console.log('APIå“åº”æ•°æ®:', data);

                if (data.thread_id) {
                    addLog('success', `âœ… å·¥ä½œæµå¯åŠ¨æˆåŠŸï¼Thread ID: ${data.thread_id}`);
                    updateStatus('running');
                    updateButtonState(true); // åˆ‡æ¢åˆ°"æš‚åœä»»åŠ¡"çŠ¶æ€
                    startTimer(); // å¯åŠ¨è®¡æ—¶å™¨
                    addLog('info', `ğŸ“‹ æµç¨‹ID: ${data.flow_id}`);
                    addLog('info', `ğŸ“‹ ç‰ˆæœ¬: ${data.version}`);
                    addLog('info', `ğŸ“‹ çŠ¶æ€: ${data.status}`);

                    if (data.inputs && Object.keys(data.inputs).length > 0) {
                        addLog('info', 'ğŸ“ è¾“å…¥æ•°æ®:');
                        displayInputData(data.inputs);
                    }

                    if (urlParams.get('form_data') === 'submitted') {
                        displayFormData(data.inputs || {});
                    }

                    startLogPolling(data.thread_id);
                } else {
                    const errorMsg = data.detail || data.message || 'æœªçŸ¥é”™è¯¯';
                    addLog('error', `âŒ å¯åŠ¨å¤±è´¥: ${errorMsg}`);
                    console.error('å¯åŠ¨å¤±è´¥è¯¦æƒ…:', data);
                }
            })
            .catch(error => {
                console.error('å¯åŠ¨å·¥ä½œæµå¤±è´¥:', error);
                addLog('error', `âŒ å¯åŠ¨å¤±è´¥: ${error.message}`);

                if (error.message.includes('404')) {
                    addLog('warning', 'ğŸ’¡ æç¤º: è¯·æ£€æŸ¥æµç¨‹IDæ˜¯å¦æ­£ç¡®ï¼Œæˆ–æµç¨‹æ˜¯å¦å·²å‘å¸ƒ');
                } else if (error.message.includes('500')) {
                    addLog('warning', 'ğŸ’¡ æç¤º: æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·æ£€æŸ¥å·¥ä½œæµå®šä¹‰æˆ–è”ç³»ç®¡ç†å‘˜');
                } else if (error.message.includes('400')) {
                    addLog('warning', 'ğŸ’¡ æç¤º: è¯·æ±‚å‚æ•°é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥æ•°æ®æ ¼å¼');
                }
            });
        }

        // æ˜¾ç¤ºè¾“å…¥æ•°æ®ï¼ˆæ ¼å¼åŒ–åˆ°æ—¥å¿—ä¸­ï¼‰
        function displayInputData(inputData) {
            Object.entries(inputData).forEach(([key, value]) => {
                let displayValue;
                if (typeof value === 'object') {
                    displayValue = JSON.stringify(value, null, 2);
                } else {
                    displayValue = String(value);
                }
                addLog('info', `   ${key}: ${displayValue}`);
            });
        }

        // æ˜¾ç¤ºè¡¨å•æ•°æ®
        function displayFormData(formData) {
            if (Object.keys(formData).length > 0) {
                // æ ¼å¼åŒ–æ˜¾ç¤ºè¡¨å•æ•°æ®
                addLog('info', 'ğŸ“ æäº¤çš„è¡¨å•æ•°æ®:');

                Object.entries(formData).forEach(([key, value]) => {
                    let displayValue;
                    if (typeof value === 'object') {
                        displayValue = JSON.stringify(value, null, 2);
                    } else {
                        displayValue = String(value);
                    }
                    addLog('info', `   ${key}: ${displayValue}`);
                });
            }
        }

        // WebSocket è¿æ¥ç®¡ç† - å¢å¼ºç‰ˆæœ¬
        let wsConnection = null;
        let currentThreadId = null;
        let heartbeatInterval = null;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectDelay = 1000; // åˆå§‹é‡è¿å»¶è¿Ÿ1ç§’

        // è¿æ¥çŠ¶æ€ç®¡ç† - å¢å¼ºç‰ˆæœ¬
        function updateConnectionStatus(status, text) {
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.querySelector('.status-text');

            if (statusDot && statusText) {
                // ç§»é™¤æ‰€æœ‰çŠ¶æ€ç±»
                statusDot.className = 'status-dot';
                statusDot.classList.add(status);
                statusText.textContent = text;

                // æ ¹æ®çŠ¶æ€æ·»åŠ ä¸åŒçš„è§†è§‰æ•ˆæœ
                if (status === 'connected') {
                    statusDot.style.animation = 'pulse 2s infinite';
                } else if (status === 'connecting') {
                    statusDot.style.animation = 'spin 1s linear infinite';
                } else {
                    statusDot.style.animation = 'none';
                }
            }
        }

        // WebSocketå¿ƒè·³æ£€æµ‹
        function startHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
            }

            heartbeatInterval = setInterval(() => {
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    wsConnection.send(JSON.stringify({
                        type: 'ping',
                        timestamp: new Date().toISOString()
                    }));
                }
            }, 30000); // æ¯30ç§’å‘é€ä¸€æ¬¡å¿ƒè·³
        }

        // åœæ­¢å¿ƒè·³æ£€æµ‹
        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }

        // å¼€å§‹æ—¥å¿—è½®è¯¢ - ä½¿ç”¨çœŸå®çš„ WebSocket è¿æ¥
        function startLogPolling(threadId) {
            console.log('å¼€å§‹å®æ—¶æ—¥å¿—ç›‘å¬ï¼ŒThread ID:', threadId);
            currentThreadId = threadId;

            // å»ºç«‹ WebSocket è¿æ¥åˆ°å·¥ä½œæµå¼•æ“
            const wsUrl = `ws://${window.location.host}/api/runs/${threadId}/events`;
            addLog('debug', `è¿æ¥åˆ° WebSocket: ${wsUrl}`);

            // æ›´æ–°è¿æ¥çŠ¶æ€ä¸ºè¿æ¥ä¸­
            updateConnectionStatus('connecting', 'è¿æ¥ä¸­...');

            try {
                wsConnection = new WebSocket(wsUrl);

                wsConnection.onopen = function(event) {
                    addLog('success', 'âœ… å®æ—¶æ—¥å¿—è¿æ¥å·²å»ºç«‹');
                    updateConnectionStatus('connected', 'å·²è¿æ¥');
                    console.log('WebSocket è¿æ¥å·²å»ºç«‹:', event);

                    // å¯åŠ¨å¿ƒè·³æ£€æµ‹
                    startHeartbeat();

                    // è¿æ¥å»ºç«‹åç«‹å³è¯·æ±‚å½“å‰çŠ¶æ€
                    if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                        wsConnection.send(JSON.stringify({
                            type: 'status_request',
                            timestamp: new Date().toISOString()
                        }));
                    }
                };

                wsConnection.onmessage = function(event) {
                    try {
                        const message = JSON.parse(event.data);
                        console.log('æ”¶åˆ° WebSocket æ¶ˆæ¯:', message);

                        if (message.type === 'log') {
                            // å¤„ç†æ—¥å¿—æ¶ˆæ¯
                            const logData = message.data;
                            const level = logData.level ? logData.level.toLowerCase() : 'info';
                            const nodeInfo = logData.node_id ? ` [${logData.node_id}]` : '';
                            const logMessage = `${logData.message}${nodeInfo}`;

                            addLog(level, logMessage);
                        } else if (message.type === 'status') {
                            // å¤„ç†çŠ¶æ€æ›´æ–°æ¶ˆæ¯
                            const statusData = message.data;
                            console.log('æ”¶åˆ°çŠ¶æ€æ›´æ–°:', statusData);

                            if (statusData && statusData.status) {
                                addLog('info', `ğŸ“Š çŠ¶æ€æ›´æ–°: ${getStatusText(statusData.status)}`);
                                updateStatus(statusData.status);

                                // åŒæ—¶æ›´æ–°æŒ‰é’®çŠ¶æ€å’Œè®¡æ—¶å™¨
                                if (statusData.status === 'running') {
                                    updateButtonState(true);
                                    if (!timerState.isRunning) {
                                        startTimer();
                                    }
                                } else if (statusData.status === 'paused') {
                                    updateButtonState(false);
                                    if (timerState.isRunning) {
                                        pauseTimer();
                                    }
                                } else if (['stopped', 'completed', 'failed', 'cancelled', 'timeout', 'error'].includes(statusData.status)) {
                                    updateButtonState(false);
                                    if (timerState.isRunning || timerState.isPaused) {
                                        stopTimer();
                                    }
                                } else if (['idle', 'pending'].includes(statusData.status)) {
                                    updateButtonState(false);
                                }
                            }
                        } else if (message.type === 'connection') {
                            addLog('info', `ğŸ“¡ ${message.status}: ${message.thread_id}`);
                        } else if (message.type === 'error') {
                            addLog('error', `âŒ é”™è¯¯: ${message.message}`);
                        } else if (message.type === 'pong') {
                            // å¤„ç†å¿ƒè·³å“åº”
                            console.log('æ”¶åˆ°å¿ƒè·³å“åº”');
                        }
                    } catch (e) {
                        console.error('è§£æ WebSocket æ¶ˆæ¯å¤±è´¥:', e, event.data);
                        addLog('warning', `âš ï¸ æ”¶åˆ°æ— æ³•è§£æçš„æ¶ˆæ¯: ${event.data}`);
                    }
                };

                wsConnection.onerror = function(error) {
                    console.error('WebSocket é”™è¯¯:', error);
                    addLog('error', 'âŒ å®æ—¶æ—¥å¿—è¿æ¥å‡ºé”™');
                    updateConnectionStatus('disconnected', 'è¿æ¥é”™è¯¯');
                    stopHeartbeat();
                };

                wsConnection.onclose = function(event) {
                    console.log('WebSocket è¿æ¥å·²å…³é—­:', event);
                    addLog('warning', 'âš ï¸ å®æ—¶æ—¥å¿—è¿æ¥å·²æ–­å¼€');
                    updateConnectionStatus('disconnected', 'å·²æ–­å¼€');
                    stopHeartbeat();

                    // å¦‚æœæ˜¯éæ­£å¸¸å…³é—­ä¸”è¿˜æœ‰æ´»åŠ¨çš„thread_idï¼Œå°è¯•é‡è¿
                    if (event.code !== 1000 && currentThreadId && reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        const delay = Math.min(reconnectDelay * Math.pow(2, reconnectAttempts - 1), 30000); // æŒ‡æ•°é€€é¿ï¼Œæœ€å¤§30ç§’

                        addLog('info', `ğŸ”„ å°è¯•é‡æ–°è¿æ¥... (${reconnectAttempts}/${maxReconnectAttempts})`);
                        updateConnectionStatus('connecting', 'é‡è¿ä¸­...');

                        setTimeout(() => {
                            if (currentThreadId) {
                                startLogPolling(currentThreadId);
                            }
                        }, delay);
                    } else if (reconnectAttempts >= maxReconnectAttempts) {
                        addLog('error', 'âŒ é‡è¿æ¬¡æ•°å·²è¾¾ä¸Šé™ï¼Œåˆ‡æ¢åˆ°HTTPè½®è¯¢æ¨¡å¼');
                        startHttpLogPolling(currentThreadId);
                    }
                };

            } catch (error) {
                console.error('åˆ›å»º WebSocket è¿æ¥å¤±è´¥:', error);
                addLog('error', `âŒ æ— æ³•å»ºç«‹å®æ—¶æ—¥å¿—è¿æ¥: ${error.message}`);

                // é™çº§åˆ° HTTP è½®è¯¢
                startHttpLogPolling(threadId);
            }
        }

        // HTTP è½®è¯¢ä½œä¸º WebSocket çš„é™çº§æ–¹æ¡ˆ
        function startHttpLogPolling(threadId) {
            addLog('info', 'ğŸ”„ ä½¿ç”¨ HTTP è½®è¯¢è·å–æ—¥å¿—');

            const pollLogs = () => {
                if (!currentThreadId || currentThreadId !== threadId) {
                    return; // åœæ­¢è½®è¯¢
                }

                fetch(`/api/thread/${threadId}/logs`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.logs && data.logs.length > 0) {
                            data.logs.forEach(log => {
                                const level = log.level ? log.level.toLowerCase() : 'info';
                                const nodeInfo = log.node_id ? ` [${log.node_id}]` : '';
                                const logMessage = `${log.message}${nodeInfo}`;
                                addLog(level, logMessage);
                            });
                        }

                        // æ£€æŸ¥å·¥ä½œæµçŠ¶æ€
                        if (data.status) {
                            updateStatus(data.status);

                            // åŒæ—¶æ›´æ–°æŒ‰é’®çŠ¶æ€
                            if (data.status === 'running') {
                                updateButtonState(true);
                            } else if (data.status === 'paused' || data.status === 'stopped' || data.status === 'completed' || data.status === 'failed' || data.status === 'cancelled' || data.status === 'timeout' || data.status === 'error') {
                                updateButtonState(false);
                            }

                            // å¦‚æœå·¥ä½œæµå®Œæˆï¼Œåœæ­¢è½®è¯¢
                            if (data.status === 'completed' || data.status === 'failed') {
                                currentThreadId = null;
                                return;
                            }
                        }

                        // ç»§ç»­è½®è¯¢
                        setTimeout(pollLogs, 2000);
                    })
                    .catch(error => {
                        console.error('è·å–æ—¥å¿—å¤±è´¥:', error);
                        addLog('error', `âŒ è·å–æ—¥å¿—å¤±è´¥: ${error.message}`);

                        // ç»§ç»­è½®è¯¢ï¼Œä½†å¢åŠ é—´éš”
                        setTimeout(pollLogs, 5000);
                    });
            };

            // å¼€å§‹è½®è¯¢
            pollLogs();
        }

        // åœæ­¢æ—¥å¿—ç›‘å¬
        function stopLogPolling() {
            currentThreadId = null;

            if (wsConnection) {
                wsConnection.close(1000, 'ç”¨æˆ·åœæ­¢ç›‘å¬');
                wsConnection = null;
                addLog('info', 'ğŸ›‘ å·²åœæ­¢å®æ—¶æ—¥å¿—ç›‘å¬');
            }
        }

        // å·¥ä½œæµçŠ¶æ€è·Ÿè¸ª
        let isWorkflowRunning = false;

        // è®¡æ—¶å™¨çŠ¶æ€ç®¡ç† - å¢åŠ  finalTime æ”¯æŒ
        let timerState = {
            startTime: null,
            pausedTime: 0,
            isRunning: false,
            isPaused: false,
            intervalId: null,
            finalTime: undefined  // ä¿å­˜æœ€ç»ˆæ—¶é—´ï¼Œç”¨äºä»»åŠ¡å®Œæˆåæ˜¾ç¤º
        };

        // æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º (HH:MM:SS)
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // æ›´æ–°è®¡æ—¶å™¨æ˜¾ç¤º - ä¼˜åŒ–ç‰ˆæœ¬ï¼šæ”¯æŒä¿æŒæœ€ç»ˆæ—¶é—´
        function updateTimerDisplay() {
            const timerDisplay = document.getElementById('timer-display');
            const timerStatus = document.getElementById('timer-status');

            if (!timerDisplay || !timerStatus) return;

            let elapsedSeconds = 0;

            if (timerState.isRunning && timerState.startTime) {
                elapsedSeconds = Math.floor((Date.now() - timerState.startTime - timerState.pausedTime) / 1000);
            } else if (timerState.isPaused && timerState.startTime) {
                elapsedSeconds = Math.floor(timerState.pausedTime / 1000);
            } else if (timerState.finalTime !== undefined) {
                // å¦‚æœæœ‰æœ€ç»ˆæ—¶é—´ï¼Œæ˜¾ç¤ºæœ€ç»ˆæ—¶é—´ï¼ˆä»»åŠ¡å®Œæˆæˆ–åœæ­¢åä¿æŒæ˜¾ç¤ºï¼‰
                elapsedSeconds = timerState.finalTime;
            }

            timerDisplay.textContent = formatTime(Math.max(0, elapsedSeconds));

            // æ›´æ–°è®¡æ—¶å™¨çŠ¶æ€æ˜¾ç¤º
            if (timerState.isRunning) {
                timerStatus.textContent = 'è¿è¡Œä¸­';
                timerStatus.className = 'timer-status running';
            } else if (timerState.isPaused) {
                timerStatus.textContent = 'å·²æš‚åœ';
                timerStatus.className = 'timer-status paused';
            } else if (timerState.finalTime !== undefined && timerState.finalTime > 0) {
                // æ˜¾ç¤ºå·²å®ŒæˆçŠ¶æ€
                timerStatus.textContent = 'å·²å®Œæˆ';
                timerStatus.className = 'timer-status completed';
            } else {
                timerStatus.textContent = 'å¾…æœº';
                timerStatus.className = 'timer-status idle';
            }
        }

        // å¯åŠ¨è®¡æ—¶å™¨
        function startTimer() {
            if (timerState.isRunning) return;

            const now = Date.now();

            if (timerState.isPaused) {
                // ä»æš‚åœçŠ¶æ€æ¢å¤
                timerState.pausedTime = now - timerState.startTime - timerState.pausedTime;
                timerState.startTime = now - timerState.pausedTime;
                timerState.isPaused = false;
                addLog('info', 'â¯ï¸ è®¡æ—¶å™¨å·²æ¢å¤');
            } else {
                // å…¨æ–°å¯åŠ¨
                timerState.startTime = now;
                timerState.pausedTime = 0;
                addLog('info', 'â–¶ï¸ è®¡æ—¶å™¨å·²å¯åŠ¨');
            }

            timerState.isRunning = true;

            // å¯åŠ¨å®šæ—¶æ›´æ–°
            if (timerState.intervalId) {
                clearInterval(timerState.intervalId);
            }
            timerState.intervalId = setInterval(updateTimerDisplay, 1000);

            updateTimerDisplay();
        }

        // æš‚åœè®¡æ—¶å™¨
        function pauseTimer() {
            if (!timerState.isRunning) return;

            const now = Date.now();
            timerState.pausedTime = now - timerState.startTime - timerState.pausedTime;
            timerState.isRunning = false;
            timerState.isPaused = true;

            if (timerState.intervalId) {
                clearInterval(timerState.intervalId);
                timerState.intervalId = null;
            }

            updateTimerDisplay();
            addLog('info', 'â¸ï¸ è®¡æ—¶å™¨å·²æš‚åœ');
        }

        // åœæ­¢è®¡æ—¶å™¨ - ä¼˜åŒ–ç‰ˆæœ¬ï¼šä¿æŒæœ€ç»ˆæ—¶é—´ï¼Œä¸é‡ç½®
        function stopTimer() {
            if (timerState.isRunning || timerState.isPaused) {
                // è®¡ç®—å¹¶ä¿å­˜æœ€ç»ˆæ—¶é—´
                let finalElapsedSeconds = 0;
                if (timerState.isRunning && timerState.startTime) {
                    finalElapsedSeconds = Math.floor((Date.now() - timerState.startTime - timerState.pausedTime) / 1000);
                } else if (timerState.isPaused && timerState.startTime) {
                    finalElapsedSeconds = Math.floor(timerState.pausedTime / 1000);
                }

                // ä¿å­˜æœ€ç»ˆæ—¶é—´åˆ°çŠ¶æ€ä¸­
                timerState.finalTime = Math.max(0, finalElapsedSeconds);

                addLog('info', `â¹ï¸ è®¡æ—¶å™¨å·²åœæ­¢ï¼Œæœ€ç»ˆæ—¶é—´: ${formatTime(timerState.finalTime)}`);
            }

            timerState.isRunning = false;
            timerState.isPaused = false;
            // æ³¨æ„ï¼šä¸é‡ç½® startTime å’Œ pausedTimeï¼Œä¿æŒå†å²è®°å½•

            if (timerState.intervalId) {
                clearInterval(timerState.intervalId);
                timerState.intervalId = null;
            }

            updateTimerDisplay();
        }

        // é‡ç½®è®¡æ—¶å™¨
        function resetTimer() {
            stopTimer();
            const timerDisplay = document.getElementById('timer-display');
            if (timerDisplay) {
                timerDisplay.textContent = '00:00:00';
            }
            addLog('info', 'ğŸ”„ è®¡æ—¶å™¨å·²é‡ç½®');
        }

        // åŠ¨æ€åˆ‡æ¢å¼€å§‹/æš‚åœæŒ‰é’®
        function toggleStartPause() {
            if (!isWorkflowRunning) {
                // å½“å‰æ˜¯"å¼€å§‹ä»»åŠ¡"çŠ¶æ€ï¼Œæ‰§è¡Œå¯åŠ¨
                startWorkflow();
            } else {
                // å½“å‰æ˜¯"æš‚åœä»»åŠ¡"çŠ¶æ€ï¼Œæ‰§è¡Œæš‚åœ
                pauseWorkflow();
            }
        }

        // æ›´æ–°æŒ‰é’®çŠ¶æ€ - å¢å¼ºç‰ˆæœ¬ï¼Œé˜²æ­¢é—ªçƒ
        function updateButtonState(isRunning) {
            const button = document.getElementById('start-pause-btn');

            if (button && isWorkflowRunning !== isRunning) {
                isWorkflowRunning = isRunning;

                // æ·»åŠ è¿‡æ¸¡æ•ˆæœ
                button.style.opacity = '0.7';

                setTimeout(() => {
                    if (isRunning) {
                        button.textContent = 'æš‚åœä»»åŠ¡';
                        button.className = 'btn btn-warning';
                    } else {
                        button.textContent = 'å¼€å§‹ä»»åŠ¡';
                        button.className = 'btn btn-success';
                    }
                    button.style.opacity = '1';
                }, 150);
            }
        }

        // å¯åŠ¨æµç¨‹ (ä¿æŒå‘åå…¼å®¹)
        function startFlow() {
            startWorkflow();
        }

        // æš‚åœå·¥ä½œæµ
        function pauseWorkflow() {
            console.log('æš‚åœæµç¨‹:', flowName);

            if (currentThreadId) {
                const flowId = "{{ flow_id }}";
                const apiUrl = `/api/thread/${currentThreadId}/pause`;

                fetch(apiUrl, { method: 'POST' })
                    .then(response => {
                        if (response.ok) {
                            return response.json();
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    })
                    .then(data => {
                        // åç«¯è¿”å› ThreadControlResponse: {thread_id, status, message}
                        if (data.status === 'pause_requested') {
                            addLog('warning', 'â¸ï¸ å·¥ä½œæµå·²æš‚åœ');
                            updateStatus('paused');
                            updateButtonState(false); // åˆ‡æ¢å›"å¼€å§‹ä»»åŠ¡"çŠ¶æ€
                            pauseTimer(); // æš‚åœè®¡æ—¶å™¨
                        } else {
                            addLog('error', `âŒ æš‚åœå¤±è´¥: ${data.message || 'æœªçŸ¥é”™è¯¯'}`);
                        }
                    })
                    .catch(error => {
                        addLog('error', `âŒ æš‚åœè¯·æ±‚å¤±è´¥: ${error.message}`);
                    });
            } else {
                addLog('warning', 'âš ï¸ æ²¡æœ‰æ­£åœ¨è¿è¡Œçš„å·¥ä½œæµ');
                updateButtonState(false); // ç¡®ä¿æŒ‰é’®çŠ¶æ€æ­£ç¡®
            }
        }

        // ä¿æŒå‘åå…¼å®¹çš„æš‚åœå‡½æ•°
        function pauseFlow() {
            pauseWorkflow();
        }

        // åœæ­¢æµç¨‹
        function stopFlow() {
            console.log('åœæ­¢æµç¨‹:', flowName);

            if (currentThreadId) {
                const flowId = "{{ flow_id }}";
                const apiUrl = `/api/thread/${currentThreadId}/stop`;

                fetch(apiUrl, { method: 'POST' })
                    .then(response => {
                        if (response.ok) {
                            return response.json();
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    })
                    .then(data => {
                        // åç«¯è¿”å› ThreadControlResponse: {thread_id, status, message}
                        if (data.status === 'stopped') {
                            addLog('warning', 'ğŸ›‘ å·¥ä½œæµå·²åœæ­¢');
                            updateStatus('stopped');
                            updateButtonState(false); // é‡ç½®ä¸º"å¼€å§‹ä»»åŠ¡"çŠ¶æ€
                            stopTimer(); // åœæ­¢è®¡æ—¶å™¨
                            stopLogPolling(); // åœæ­¢æ—¥å¿—ç›‘å¬
                        } else {
                            addLog('error', `âŒ åœæ­¢å¤±è´¥: ${data.message || 'æœªçŸ¥é”™è¯¯'}`);
                        }
                    })
                    .catch(error => {
                        addLog('error', `âŒ åœæ­¢è¯·æ±‚å¤±è´¥: ${error.message}`);
                    });
            } else {
                addLog('warning', 'âš ï¸ æ²¡æœ‰æ­£åœ¨è¿è¡Œçš„å·¥ä½œæµ');
                stopLogPolling(); // å³ä½¿æ²¡æœ‰è¿è¡Œçš„å·¥ä½œæµï¼Œä¹Ÿåœæ­¢æ—¥å¿—ç›‘å¬
            }
        }



        // æ›´æ–°çŠ¶æ€ - ä¼˜åŒ–ç‰ˆæœ¬ï¼šé€‚é…æ–°çš„å¸ƒå±€ç»“æ„
        function updateStatus(status) {
            const statusInfo = document.getElementById('status-info');

            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            if (statusInfo) {
                statusInfo.textContent = getStatusText(status);
                statusInfo.className = `status-display ${status}`;
            }

            // æ ¹æ®çŠ¶æ€æ›´æ–°è®¡æ—¶å™¨çŠ¶æ€
            if (['completed', 'stopped', 'failed', 'cancelled', 'timeout', 'error'].includes(status)) {
                // ä»»åŠ¡ç»“æŸçŠ¶æ€ï¼šåœæ­¢è®¡æ—¶å™¨ä½†ä¿æŒæœ€ç»ˆæ—¶é—´
                if (timerState.isRunning || timerState.isPaused) {
                    stopTimer();
                }

                // æ›´æ–°è®¡æ—¶å™¨çŠ¶æ€æ–‡æœ¬ä»¥åæ˜ ä»»åŠ¡ç»“æŸ
                const timerStatus = document.getElementById('timer-status');
                if (timerStatus && timerState.finalTime !== undefined && timerState.finalTime > 0) {
                    if (status === 'completed') {
                        timerStatus.textContent = 'å·²å®Œæˆ';
                        timerStatus.className = 'timer-status completed';
                    } else {
                        timerStatus.textContent = 'å·²åœæ­¢';
                        timerStatus.className = 'timer-status stopped';
                    }
                }
            }
        }

        // è·å–çŠ¶æ€æ–‡æœ¬
        function getStatusText(status) {
            const statusMap = {
                'idle': 'ç©ºé—²',
                'pending': 'ç­‰å¾…ä¸­',
                'running': 'è¿è¡Œä¸­',
                'paused': 'å·²æš‚åœ',
                'stopped': 'å·²åœæ­¢',
                'completed': 'å·²å®Œæˆ',
                'failed': 'å¤±è´¥',
                'error': 'é”™è¯¯',
                'cancelled': 'å·²å–æ¶ˆ',
                'timeout': 'è¶…æ—¶'
            };
            return statusMap[status] || status;
        }

        // åŠ è½½æ—¥å¿—
        function loadLogs() {
            const container = document.getElementById('logs-container');
            const logs = [
                { time: '2025-10-22 17:18:00', level: 'INFO', message: `æµç¨‹ ${flowName} åˆå§‹åŒ–å®Œæˆ` },
                { time: '2025-10-22 17:18:01', level: 'INFO', message: 'ç­‰å¾…è§¦å‘æ‰§è¡Œ...' }
            ];

            let html = '';
            logs.forEach(log => {
                const logClass = `log-${log.level.toLowerCase()}`;
                html += `<div class="log-entry ${logClass}">[${log.time}] [${log.level}] ${log.message}</div>`;
            });

            container.innerHTML = html || '<p style="color: #9E9E9E;">æš‚æ— æ—¥å¿—è®°å½•</p>';
        }

        // æ·»åŠ æ—¥å¿—
        function addLog(level, message) {
            const container = document.getElementById('logs-container');
            const now = new Date().toLocaleString();

            // åˆ›å»ºå¸¦é¢œè‰²çš„æ—¥å¿—æ¡ç›®
            const logClass = `log-${level.toLowerCase()}`;
            const logEntry = `<div class="log-entry ${logClass}">[${now}] [${level.toUpperCase()}] ${message}</div>`;

            if (container.innerHTML.includes('æš‚æ— æ—¥å¿—è®°å½•')) {
                container.innerHTML = logEntry;
            } else {
                container.innerHTML += logEntry;
            }

            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            container.scrollTop = container.scrollHeight;
        }

        // æ¸…ç©ºæ—¥å¿—
        function clearLogs() {
            document.getElementById('logs-container').innerHTML = '<p style="color: #9E9E9E;">æš‚æ— æ—¥å¿—è®°å½•</p>';
        }

        // åˆ·æ–°çŠ¶æ€
        function refreshStatus() {
            if (currentThreadId) {
                addLog('info', 'ğŸ”„ æ‰‹åŠ¨åˆ·æ–°çŠ¶æ€...');

                fetch(`/api/thread/${currentThreadId}/status`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status) {
                            console.log('æ‰‹åŠ¨åˆ·æ–°è·å–çŠ¶æ€:', data.status);
                            addLog('info', `ğŸ“Š å½“å‰çŠ¶æ€: ${getStatusText(data.status)}`);
                            updateStatus(data.status);

                            // æ›´æ–°æŒ‰é’®çŠ¶æ€
                            if (data.status === 'running') {
                                updateButtonState(true);
                            } else {
                                updateButtonState(false);
                            }
                        } else {
                            addLog('warning', 'âš ï¸ æ— æ³•è·å–çŠ¶æ€ä¿¡æ¯');
                        }
                    })
                    .catch(error => {
                        console.error('åˆ·æ–°çŠ¶æ€å¤±è´¥:', error);
                        addLog('error', `âŒ åˆ·æ–°çŠ¶æ€å¤±è´¥: ${error.message}`);
                    });
            } else {
                addLog('warning', 'âš ï¸ æ²¡æœ‰æ´»åŠ¨çš„å·¥ä½œæµ');
                updateStatus('idle');
                updateButtonState(false);
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('æµç¨‹æ§åˆ¶å°åˆå§‹åŒ–å®Œæˆ:', flowContext);
            addLog('info', `æµç¨‹æ§åˆ¶å°å·²åŠ è½½: ${appName}/${flowName}`);

            // åˆå§‹åŒ–è¿æ¥çŠ¶æ€
            updateConnectionStatus('disconnected', 'æœªè¿æ¥');

            // åˆå§‹åŒ–è®¡æ—¶å™¨æ˜¾ç¤º
            updateTimerDisplay();

            // æ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†çš„thread_id
            const urlParams = new URLSearchParams(window.location.search);
            const pendingThreadId = urlParams.get('thread_id');
            if (pendingThreadId) {
                addLog('info', `æ£€æµ‹åˆ°å¾…å¤„ç†çš„å·¥ä½œæµ: ${pendingThreadId}`);
                currentThreadId = pendingThreadId;

                // ç«‹å³è¿æ¥WebSocketå¹¶è·å–å½“å‰çŠ¶æ€
                startLogPolling(pendingThreadId);

                // åŒæ—¶é€šè¿‡HTTP APIè·å–å½“å‰çŠ¶æ€ä½œä¸ºå¤‡ä»½
                refreshStatus();
            } else {
                // æ²¡æœ‰thread_idæ—¶ï¼Œæ˜¾ç¤ºåˆå§‹çŠ¶æ€
                updateStatus('idle');
                updateButtonState(false);
            }
        });
    </script>
</body>
</html>