"""
é€‰è¯„ä¸“ç”¨æµè§ˆå™¨æœåŠ¡

åŸºäºç°æœ‰çš„ src_new/rpa/browser æ¡†æ¶ï¼Œä¸ºé€‰è¯„ç³»ç»Ÿæä¾›ä¸“é—¨çš„æµè§ˆå™¨è‡ªåŠ¨åŒ–æœåŠ¡
"""

import asyncio
import logging
import os
import sys
from typing import Dict, Any, Optional, List
from pathlib import Path

from rpa.browser.browser_service import SimplifiedBrowserService, create_debug_browser_service, create_shared_browser_service
from rpa.browser.core.config.config import create_default_browser_service_config
from rpa.browser.core.exceptions.browser_exceptions import BrowserError

from ..models import ScrapingError, ScrapingResult


class XuanpingBrowserService:
    """
    é€‰è¯„æµè§ˆå™¨æœåŠ¡ - å°è£…æµè§ˆå™¨æ“ä½œçš„é«˜çº§æ¥å£

    æä¾›é€‰è¯„ç½‘ç«™ç‰¹å®šçš„æµè§ˆå™¨æ“ä½œåŠŸèƒ½ï¼ŒåŒ…æ‹¬ï¼š
    - è‡ªåŠ¨æ£€æµ‹å’Œä½¿ç”¨ç°æœ‰æµè§ˆå™¨å®ä¾‹
    - æ™ºèƒ½é…ç½®æµè§ˆå™¨å‚æ•°
    - é¡µé¢æ•°æ®æŠ“å–
    - é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

    ğŸ”§ è®¾è®¡è¯´æ˜ï¼š
    - ä½¿ç”¨å…¨å±€å•ä¾‹æ¨¡å¼ï¼Œç¡®ä¿æ‰€æœ‰å®ä¾‹å…±äº«åŒä¸€ä¸ªæµè§ˆå™¨
    - ä¸åœ¨è¿™ä¸€å±‚å¤„ç†æµè§ˆå™¨åˆ›å»ºé€»è¾‘ï¼Œåªè´Ÿè´£è·å–å’Œä½¿ç”¨å…¨å±€å®ä¾‹
    - ä¿æŒæ¥å£ç®€å•ï¼Œåˆ†å±‚æ¸…æ™°
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        åˆå§‹åŒ–é€‰è¯„æµè§ˆå™¨æœåŠ¡

        Args:
            config: é…ç½®å­—å…¸ï¼ˆä»…ç¬¬ä¸€æ¬¡åˆ›å»ºæ—¶ä½¿ç”¨ï¼‰
        """
        self.logger = logging.getLogger(__name__)
        self.config = config or {}

        # ğŸ”§ å…³é”®ä¿®å¤ï¼šç›´æ¥è·å–å…¨å±€æµè§ˆå™¨æœåŠ¡å®ä¾‹
        # ä¸åœ¨è¿™ä¸€å±‚å¤„ç†åˆ›å»ºé€»è¾‘ï¼Œä¿æŒåˆ†å±‚æ¸…æ™°
        self.browser_service = _get_global_browser_service(config)

        # çŠ¶æ€ç®¡ç†ï¼ˆå®ä¾‹çº§åˆ«ï¼‰
        self._initialized = False
        self._browser_started = False
    
    def _create_browser_config_DEPRECATED(self, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        åˆ›å»ºæµè§ˆå™¨é…ç½®

        ğŸ”§ é‡æ„é€»è¾‘ï¼š
        1. æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦åœ¨è¿è¡Œ
        2. æ£€æµ‹æœ€è¿‘ä½¿ç”¨çš„ Profile
        3. é…ç½®ä¸ºè¿æ¥æ¨¡å¼æˆ–å¯åŠ¨æ¨¡å¼
        """
        from rpa.browser.utils import detect_active_profile, BrowserDetector
        import json
        import os

        # ä»ç¯å¢ƒå˜é‡è·å–é…ç½®
        browser_type = os.environ.get('PREFERRED_BROWSER', 'edge').lower()
        debug_port = os.environ.get('BROWSER_DEBUG_PORT', '9222')

        # æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦åœ¨è¿è¡Œ
        detector = BrowserDetector()
        is_browser_running = detector.is_browser_running()

        if not is_browser_running:
            # å¯åŠ¨æ¨¡å¼ï¼šæµè§ˆå™¨æœªè¿è¡Œ
            self.logger.info("ğŸš€ æœªæ£€æµ‹åˆ°è¿è¡Œä¸­çš„æµè§ˆå™¨ï¼Œé…ç½®ä¸ºå¯åŠ¨æ¨¡å¼")

            # ä»é…ç½®è¯»å– headless æ¨¡å¼
            browser_config_dict = self.config.get('browser', {})
            headless = browser_config_dict.get('headless', False)

            # æ£€æµ‹æœ€è¿‘ä½¿ç”¨çš„ Profile
            active_profile = detect_active_profile()

            # è·å–ç”¨æˆ·æ•°æ®ç›®å½•ï¼ˆçˆ¶ç›®å½•ï¼‰
            base_user_data_dir = detector._get_edge_user_data_dir() if browser_type == 'edge' else None

            if not active_profile:
                active_profile = "Default"
                self.logger.warning("âš ï¸ æœªæ£€æµ‹åˆ° Profileï¼Œå°†ä½¿ç”¨é»˜è®¤ Profile")
            else:
                self.logger.info(f"âœ… æ£€æµ‹åˆ°æœ€è¿‘ä½¿ç”¨çš„ Profile: {active_profile}")

            if not base_user_data_dir:
                self.logger.error("âŒ æ— æ³•è·å–ç”¨æˆ·æ•°æ®ç›®å½•")
                raise RuntimeError("æ— æ³•è·å–ç”¨æˆ·æ•°æ®ç›®å½•")

            # ğŸ”§ å…³é”®ä¿®å¤ï¼šä½¿ç”¨å®Œæ•´çš„ Profile è·¯å¾„ï¼Œè€Œä¸æ˜¯çˆ¶ç›®å½•
            # Playwright çš„ launch_persistent_context éœ€è¦å®Œæ•´çš„ Profile è·¯å¾„
            # å¦åˆ™ä¼šåˆ›å»ºæ–°çš„ Profileï¼ˆå¦‚ "Profile 1"ï¼‰
            import os
            user_data_dir = os.path.join(base_user_data_dir, active_profile)

            self.logger.info(f"ğŸ“ åŸºç¡€ç”¨æˆ·æ•°æ®ç›®å½•: {base_user_data_dir}")
            self.logger.info(f"ğŸ“ Profile åç§°: {active_profile}")
            self.logger.info(f"ğŸ“ å®Œæ•´ Profile è·¯å¾„: {user_data_dir}")

            # å¯åŠ¨æ¨¡å¼é…ç½®
            # ğŸ”§ ä½¿ç”¨ user_data_dir ä¿æŒç™»å½•çŠ¶æ€ï¼Œé€šè¿‡ç±»çº§åˆ«å…±äº«å®ä¾‹é¿å…æ— é™æµè§ˆå™¨è¿›ç¨‹
            config = {
                'debug_mode': True,
                'browser_config': {
                    'browser_type': browser_type,
                    'headless': headless,
                    'debug_port': int(debug_port),
                    'user_data_dir': user_data_dir,  # ğŸ”§ ä¿ç•™ user_data_dir ä»¥ä¿æŒç™»å½•çŠ¶æ€
                    'viewport': {
                        'width': 1280,
                        'height': 800
                    },
                    'launch_args': []  # ä¸éœ€è¦ --profile-directoryï¼Œè·¯å¾„å·²åŒ…å«
                },
                'use_persistent_context': False,
                'connect_to_existing': False
            }

            self.logger.info(f"ğŸš€ é…ç½®ä¸ºå¯åŠ¨æ¨¡å¼: headless={headless}, profile={active_profile}")
            return config

        # è¿æ¥æ¨¡å¼ï¼šæµè§ˆå™¨æ­£åœ¨è¿è¡Œ
        self.logger.info("ğŸ”— æ£€æµ‹åˆ°è¿è¡Œä¸­çš„æµè§ˆå™¨ï¼Œå°è¯•è¿æ¥æ¨¡å¼")

        # æ£€æµ‹æœ€è¿‘ä½¿ç”¨çš„ Profile
        active_profile = detect_active_profile()

        if not active_profile:
            self.logger.warning("âš ï¸ æœªæ‰¾åˆ°æµè§ˆå™¨ Profileï¼Œåˆ‡æ¢åˆ°å¯åŠ¨æ¨¡å¼")
            active_profile = "Default"
        else:
            self.logger.info(f"âœ… æ£€æµ‹åˆ°æœ€è¿‘ä½¿ç”¨çš„ Profile: {active_profile}")

        # æ£€æŸ¥ç°æœ‰æµè§ˆå™¨çš„è°ƒè¯•ç«¯å£
        existing_browser = self._check_existing_browser(debug_port)

        if not existing_browser:
            error_msg = (
                f"âŒ æµè§ˆå™¨æ­£åœ¨è¿è¡Œï¼Œä½†è°ƒè¯•ç«¯å£ {debug_port} æœªå¼€å¯\n"
                f"ğŸ’¡ è¯·å…³é—­æµè§ˆå™¨ï¼Œç„¶åé‡æ–°è¿è¡Œç¨‹åºï¼ˆç¨‹åºä¼šè‡ªåŠ¨å¯åŠ¨æµè§ˆå™¨ï¼‰"
            )
            self.logger.error(error_msg)
            raise RuntimeError(error_msg)

        self.logger.info(f"âœ… æ£€æµ‹åˆ°æµè§ˆå™¨è°ƒè¯•ç«¯å£: {debug_port}")

        # ğŸ”§ å…³é”®ä¿®å¤ï¼šåªé…ç½®è¿æ¥æ¨¡å¼ï¼Œä¸å…è®¸å¯åŠ¨æ–°æµè§ˆå™¨
        config = {
            'debug_mode': True,
            'browser_config': {
                'browser_type': browser_type,
                'headless': False,
                'debug_port': int(debug_port),
                'user_data_dir': None,  # è¿æ¥æ¨¡å¼ä¸éœ€è¦æŒ‡å®šç”¨æˆ·æ•°æ®ç›®å½•
                'viewport': {
                    'width': 1280,
                    'height': 800
                },
                'launch_args': []  # è¿æ¥æ¨¡å¼ä¸éœ€è¦å¯åŠ¨å‚æ•°
            },
            'use_persistent_context': False,  # è¿æ¥æ¨¡å¼ä¸ä½¿ç”¨æŒä¹…åŒ–ä¸Šä¸‹æ–‡
            'connect_to_existing': True,  # å¼ºåˆ¶è¿æ¥æ¨¡å¼
            'profile_name': active_profile
        }

        self.logger.info(f"ğŸ”— é…ç½®ä¸ºè¿æ¥æ¨¡å¼: Profile={active_profile}, Port={debug_port}")

        return config

    def _check_existing_browser(self, debug_port: str) -> bool:
        """
        æ£€æŸ¥æ˜¯å¦æœ‰ç°æœ‰æµè§ˆå™¨åœ¨æŒ‡å®šè°ƒè¯•ç«¯å£è¿è¡Œï¼Œå¹¶ä¸” CDP ç«¯ç‚¹å¯ç”¨

        ğŸ”§ å…³é”®ä¿®å¤ï¼šä¸ä»…æ£€æŸ¥ç«¯å£æ˜¯å¦è¢«å ç”¨ï¼Œè¿˜è¦éªŒè¯ CDP ç«¯ç‚¹æ˜¯å¦çœŸçš„å¯ç”¨
        """
        try:
            import socket
            import urllib.request
            import json

            # ç¬¬ä¸€æ­¥ï¼šæ£€æŸ¥ç«¯å£æ˜¯å¦è¢«å ç”¨
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)  # 1ç§’è¶…æ—¶
            result = sock.connect_ex(('localhost', int(debug_port)))
            sock.close()

            if result != 0:
                self.logger.info(f"ğŸ” ç«¯å£ {debug_port} æœªè¢«å ç”¨ï¼Œéœ€è¦åˆ›å»ºæ–°æµè§ˆå™¨å®ä¾‹")
                return False

            # ç¬¬äºŒæ­¥ï¼šéªŒè¯ CDP ç«¯ç‚¹æ˜¯å¦å¯ç”¨
            # å°è¯•è®¿é—® /json/version ç«¯ç‚¹æ¥ç¡®è®¤ CDP æ˜¯å¦çœŸçš„å¯ç”¨
            cdp_url = f"http://localhost:{debug_port}/json/version"
            try:
                req = urllib.request.Request(cdp_url, headers={'User-Agent': 'Mozilla/5.0'})
                with urllib.request.urlopen(req, timeout=2) as response:
                    data = json.loads(response.read().decode('utf-8'))
                    # æ£€æŸ¥æ˜¯å¦æœ‰ webSocketDebuggerUrl å­—æ®µ
                    if 'webSocketDebuggerUrl' in data:
                        self.logger.info(f"âœ… æ£€æµ‹åˆ°ç°æœ‰æµè§ˆå™¨å®ä¾‹åœ¨ç«¯å£ {debug_port}ï¼ŒCDP ç«¯ç‚¹å¯ç”¨")
                        return True
                    else:
                        self.logger.warning(f"âš ï¸ ç«¯å£ {debug_port} è¢«å ç”¨ï¼Œä½† CDP ç«¯ç‚¹ä¸å¯ç”¨")
                        return False
            except Exception as cdp_error:
                self.logger.warning(f"âš ï¸ ç«¯å£ {debug_port} è¢«å ç”¨ï¼Œä½†æ— æ³•è®¿é—® CDP ç«¯ç‚¹: {cdp_error}")
                return False

        except Exception as e:
            self.logger.debug(f"æ£€æŸ¥ç°æœ‰æµè§ˆå™¨å¤±è´¥: {e}")
            return False
    
    async def initialize(self) -> bool:
        """
        åˆå§‹åŒ–æµè§ˆå™¨æœåŠ¡
        
        ğŸ”§ è®¾è®¡è¯´æ˜ï¼š
        - ä½¿ç”¨å…¨å±€åˆå§‹åŒ–æ ‡å¿—ï¼Œç¡®ä¿æµè§ˆå™¨åªåˆå§‹åŒ–ä¸€æ¬¡
        - å¤šä¸ªå®ä¾‹è°ƒç”¨æ—¶ï¼Œåªæœ‰ç¬¬ä¸€ä¸ªä¼šçœŸæ­£åˆå§‹åŒ–

        Returns:
            bool: åˆå§‹åŒ–æ˜¯å¦æˆåŠŸ
        """
        global _global_initialized

        try:
            if self._initialized:
                return True

            # ğŸ”§ å…³é”®ä¿®å¤ï¼šä½¿ç”¨å…¨å±€åˆå§‹åŒ–æ ‡å¿—
            with _global_lock:
                if not _global_initialized:
                    self.logger.info("ğŸ”§ å¼€å§‹åˆå§‹åŒ–å…¨å±€æµè§ˆå™¨æœåŠ¡")

                    # åˆå§‹åŒ–æµè§ˆå™¨æœåŠ¡
                    success = await self.browser_service.initialize()
                    if not success:
                        raise ScrapingError("æµè§ˆå™¨æœåŠ¡åˆå§‹åŒ–å¤±è´¥")

                    _global_initialized = True
                    self.logger.info("âœ… å…¨å±€æµè§ˆå™¨æœåŠ¡åˆå§‹åŒ–å®Œæˆ")
                else:
                    self.logger.info("â™»ï¸ å…¨å±€æµè§ˆå™¨æœåŠ¡å·²åˆå§‹åŒ–ï¼Œè·³è¿‡")

            self._initialized = True
            return True

        except Exception as e:
            self.logger.error(f"âŒ æµè§ˆå™¨æœåŠ¡åˆå§‹åŒ–å¤±è´¥: {e}")
            return False
    
    async def start_browser(self) -> bool:
        """
        å¯åŠ¨æµè§ˆå™¨ - ğŸ”§ å…³é”®ä¿®å¤ï¼šä¼˜å…ˆè¿æ¥ç°æœ‰æµè§ˆå™¨ï¼Œå¤±è´¥æ—¶æä¾›ç”¨æˆ·å‹å¥½çš„è§£å†³æ–¹æ¡ˆ

        Returns:
            bool: å¯åŠ¨æ˜¯å¦æˆåŠŸ
        """
        try:
            if not self._initialized:
                await self.initialize()

            if self._browser_started:
                return True

            self.logger.info("ğŸŒ å¯åŠ¨æµè§ˆå™¨")

            # ğŸ”§ å…³é”®ä¿®å¤ï¼šå°è¯•å¯åŠ¨æµè§ˆå™¨ï¼Œå¦‚æœå¤±è´¥åˆ™æä¾›è§£å†³æ–¹æ¡ˆ
            try:
                success = await self.browser_service.start_browser()
                if success:
                    self._browser_started = True
                    self.logger.info("âœ… æµè§ˆå™¨å¯åŠ¨æˆåŠŸ")
                    return True
                else:
                    raise ScrapingError("æµè§ˆå™¨å¯åŠ¨å¤±è´¥")

            except Exception as browser_error:
                # ğŸ”§ å…³é”®ä¿®å¤ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯æµè§ˆå™¨è¿›ç¨‹å†²çªé—®é¢˜
                error_msg = str(browser_error).lower()
                if "processingleton" in error_msg or "already in use" in error_msg or "profile is already" in error_msg:
                    self.logger.warning("âš ï¸ æ£€æµ‹åˆ°æµè§ˆå™¨è¿›ç¨‹å†²çªï¼Œå°è¯•è§£å†³æ–¹æ¡ˆ...")

                    # å°è¯•è§£å†³æ–¹æ¡ˆ1ï¼šç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
                    self.logger.info("ğŸ”„ ç­‰å¾…3ç§’åé‡è¯•...")
                    await asyncio.sleep(3)

                    try:
                        success = await self.browser_service.start_browser()
                        if success:
                            self._browser_started = True
                            self.logger.info("âœ… é‡è¯•æˆåŠŸï¼Œæµè§ˆå™¨å¯åŠ¨å®Œæˆ")
                            return True
                    except Exception:
                        pass

                    # ğŸ”§ å…³é”®ä¿®å¤ï¼šæä¾›ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯å’Œè§£å†³æ–¹æ¡ˆ
                    self.logger.error("âŒ æµè§ˆå™¨è¿›ç¨‹å†²çªæ— æ³•è‡ªåŠ¨è§£å†³")
                    self.logger.error("ğŸ’¡ è§£å†³æ–¹æ¡ˆï¼š")
                    self.logger.error("   1. å…³é—­æ‰€æœ‰ Edge æµè§ˆå™¨çª—å£")
                    self.logger.error("   2. æˆ–è€…åœ¨ç»ˆç«¯è¿è¡Œï¼špkill -f 'Microsoft Edge'")
                    self.logger.error("   3. ç„¶åé‡æ–°è¿è¡Œç¨‹åº")

                    # ğŸ”§ ä¸ç›´æ¥é€€å‡ºç¨‹åºï¼Œè€Œæ˜¯è¿”å›å¤±è´¥çŠ¶æ€
                    return False
                else:
                    # å…¶ä»–ç±»å‹çš„é”™è¯¯
                    raise browser_error

        except Exception as e:
            self.logger.error(f"âŒ æµè§ˆå™¨å¯åŠ¨å¤±è´¥: {e}")
            return False
    
    async def navigate_to(self, url: str) -> bool:
        """
        å¯¼èˆªåˆ°æŒ‡å®šURL
        
        Args:
            url: ç›®æ ‡URL
            
        Returns:
            bool: å¯¼èˆªæ˜¯å¦æˆåŠŸ
        """
        try:
            if not self._browser_started:
                await self.start_browser()
            
            self.logger.info(f"ğŸ”— å¯¼èˆªåˆ°: {url}")
            
            success = await self.browser_service.navigate_to(url)
            if success:
                self.logger.info("âœ… é¡µé¢å¯¼èˆªæˆåŠŸ")
            
            return success
            
        except Exception as e:
            self.logger.error(f"âŒ é¡µé¢å¯¼èˆªå¤±è´¥: {e}")
            return False
    
    async def scrape_page_data(self, url: str, extractor_func) -> ScrapingResult:
        """
        æŠ“å–é¡µé¢æ•°æ®
        
        Args:
            url: ç›®æ ‡URL
            extractor_func: æ•°æ®æå–å‡½æ•°
            
        Returns:
            ScrapingResult: æŠ“å–ç»“æœ
        """
        # ğŸ”§ Task 3.2 (P1-9): ä½¿ç”¨ get_running_loop() æ›¿ä»£ get_event_loop()
        start_time = asyncio.get_running_loop().time()

        try:
            # å¯¼èˆªåˆ°é¡µé¢
            success = await self.navigate_to(url)
            if not success:
                return ScrapingResult(
                    success=False,
                    data={},
                    error_message="é¡µé¢å¯¼èˆªå¤±è´¥",
                    execution_time=asyncio.get_running_loop().time() - start_time
                )
            
            # ç­‰å¾…é¡µé¢åŠ è½½
            await asyncio.sleep(1)
            
            # æå–æ•°æ®
            data = await extractor_func(self.browser_service)
            
            # ğŸ”§ Task 3.2 (P1-9): ä½¿ç”¨ get_running_loop() æ›¿ä»£ get_event_loop()
            execution_time = asyncio.get_running_loop().time() - start_time

            return ScrapingResult(
                success=True,
                data=data,
                execution_time=execution_time
            )

        except Exception as e:
            # ğŸ”§ Task 3.2 (P1-9): ä½¿ç”¨ get_running_loop() æ›¿ä»£ get_event_loop()
            execution_time = asyncio.get_running_loop().time() - start_time
            self.logger.error(f"âŒ é¡µé¢æ•°æ®æŠ“å–å¤±è´¥: {e}")
            
            return ScrapingResult(
                success=False,
                data={},
                error_message=str(e),
                execution_time=execution_time
            )
    
    async def get_page_content(self) -> str:
        """
        è·å–é¡µé¢å†…å®¹
        
        Returns:
            str: é¡µé¢HTMLå†…å®¹
        """
        try:
            return await self.browser_service.get_page_content()
        except Exception as e:
            self.logger.error(f"âŒ è·å–é¡µé¢å†…å®¹å¤±è´¥: {e}")
            return ""
    
    async def close(self, force: bool = False) -> bool:
        """
        å…³é—­æµè§ˆå™¨æœåŠ¡

        ğŸ”§ å…³é”®ä¿®å¤ï¼šç§»é™¤å¼•ç”¨è®¡æ•°ï¼Œç›´æ¥ä½¿ç”¨ SimplifiedBrowserService çš„å…±äº«å®ä¾‹æœºåˆ¶
        - SimplifiedBrowserService ä¼šè‡ªåŠ¨ç®¡ç†å…±äº«å®ä¾‹
        - ä¸éœ€è¦åœ¨è¿™ä¸€å±‚å†åšå¼•ç”¨è®¡æ•°

        Args:
            force: æ˜¯å¦å¼ºåˆ¶å…³é—­ï¼ˆæš‚æ—¶ä¿ç•™å‚æ•°ä»¥ä¿æŒå…¼å®¹æ€§ï¼Œä½†ä¸ä½¿ç”¨ï¼‰

        Returns:
            bool: å…³é—­æ˜¯å¦æˆåŠŸ
        """
        try:
            # ğŸ”§ å…³é”®ä¿®å¤ï¼šç›´æ¥è°ƒç”¨ browser_service.close()
            # SimplifiedBrowserService ä¼šè‡ªåŠ¨å¤„ç†å…±äº«å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸ
            success = await self.browser_service.close()
            
            self._initialized = False
            self._browser_started = False
            
            if success:
                self.logger.info("âœ… é€‰è¯„æµè§ˆå™¨æœåŠ¡å·²å…³é—­")
            
            return success
            
        except Exception as e:
            self.logger.error(f"âŒ å…³é—­é€‰è¯„æµè§ˆå™¨æœåŠ¡å¤±è´¥: {e}")
            return False
    
    # ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ”¯æŒ
    async def __aenter__(self):
        """å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨å…¥å£"""
        await self.initialize()
        await self.start_browser()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨å‡ºå£"""
        await self.close()


# å·¥å‚å‡½æ•°
def create_xuanping_browser_service(config: Optional[Dict[str, Any]] = None) -> XuanpingBrowserService:
    """
    åˆ›å»ºé€‰è¯„æµè§ˆå™¨æœåŠ¡
    
    Args:
        config: é…ç½®å­—å…¸
        
    Returns:
        XuanpingBrowserService: é€‰è¯„æµè§ˆå™¨æœåŠ¡å®ä¾‹
    """
    return XuanpingBrowserService(config)


# åŒæ­¥åŒ…è£…å™¨ï¼ˆå‘åå…¼å®¹ï¼‰
class XuanpingBrowserServiceSync:
    """
    é€‰è¯„æµè§ˆå™¨æœåŠ¡çš„åŒæ­¥åŒ…è£…å™¨
    
    ç›´æ¥æš´éœ²å¸¸ç”¨å¯¹è±¡ä»¥ç®€åŒ– APIï¼š
    - browser_service.page: Playwright Page å¯¹è±¡
    - browser_service.browser: Browser å¯¹è±¡
    - browser_service.context: BrowserContext å¯¹è±¡

    ğŸ”§ å…³é”®ä¿®å¤ï¼šä½¿ç”¨å…±äº«äº‹ä»¶å¾ªç¯ç¡®ä¿æ‰€æœ‰ Playwright æ“ä½œåœ¨åŒä¸€ä¸ªäº‹ä»¶å¾ªç¯ä¸­æ‰§è¡Œ
    """

    # ç±»çº§åˆ«çš„å…±äº«äº‹ä»¶å¾ªç¯å’Œçº¿ç¨‹
    _shared_loop: Optional[asyncio.AbstractEventLoop] = None
    _shared_thread: Optional[Any] = None
    _loop_lock = None  # å°†åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶åˆå§‹åŒ–

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.async_service = XuanpingBrowserService(config)
        self.logger = logging.getLogger(__name__)

        # åˆå§‹åŒ–é”
        if XuanpingBrowserServiceSync._loop_lock is None:
            import threading
            XuanpingBrowserServiceSync._loop_lock = threading.Lock()

        # ç¡®ä¿å…±äº«äº‹ä»¶å¾ªç¯å·²å¯åŠ¨
        self._ensure_shared_loop()

        # ç›´æ¥æš´éœ²å¸¸ç”¨å±æ€§ï¼ˆåˆå§‹ä¸º Noneï¼Œå¯åŠ¨æµè§ˆå™¨åæ›´æ–°ï¼‰
        self.page = None
        self.browser = None
        self.context = None

    def _ensure_shared_loop(self):
        """ç¡®ä¿å…±äº«äº‹ä»¶å¾ªç¯å·²å¯åŠ¨ - ğŸ”§ å…³é”®ä¿®å¤ï¼šæ‰€æœ‰å®ä¾‹å…±äº«åŒä¸€ä¸ªäº‹ä»¶å¾ªç¯"""
        import threading

        with XuanpingBrowserServiceSync._loop_lock:
            if XuanpingBrowserServiceSync._shared_loop is not None:
                # æ£€æŸ¥äº‹ä»¶å¾ªç¯æ˜¯å¦ä»åœ¨è¿è¡Œ
                if XuanpingBrowserServiceSync._shared_loop.is_running():
                    return
                else:
                    # äº‹ä»¶å¾ªç¯å·²åœæ­¢ï¼Œéœ€è¦é‡æ–°åˆ›å»º
                    self.logger.warning("âš ï¸ å…±äº«äº‹ä»¶å¾ªç¯å·²åœæ­¢ï¼Œé‡æ–°åˆ›å»º")
                    XuanpingBrowserServiceSync._shared_loop = None
                    XuanpingBrowserServiceSync._shared_thread = None

            # åˆ›å»ºæ–°çš„äº‹ä»¶å¾ªç¯å’Œçº¿ç¨‹
            def run_event_loop():
                """åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡Œäº‹ä»¶å¾ªç¯"""
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                XuanpingBrowserServiceSync._shared_loop = loop

                self.logger.info("ğŸ”„ å…±äº«äº‹ä»¶å¾ªç¯å·²å¯åŠ¨")

                try:
                    loop.run_forever()
                except Exception as e:
                    self.logger.error(f"âŒ å…±äº«äº‹ä»¶å¾ªç¯å¼‚å¸¸: {e}")
                finally:
                    try:
                        # æ¸…ç†æœªå®Œæˆçš„ä»»åŠ¡
                        pending = asyncio.all_tasks(loop)
                        for task in pending:
                            task.cancel()
                        loop.run_until_complete(asyncio.gather(*pending, return_exceptions=True))
                        loop.close()
                    except Exception as e:
                        self.logger.error(f"âŒ æ¸…ç†äº‹ä»¶å¾ªç¯å¤±è´¥: {e}")

                    XuanpingBrowserServiceSync._shared_loop = None
                    self.logger.info("ğŸ›‘ å…±äº«äº‹ä»¶å¾ªç¯å·²åœæ­¢")

            # å¯åŠ¨äº‹ä»¶å¾ªç¯çº¿ç¨‹
            thread = threading.Thread(target=run_event_loop, daemon=True, name="AsyncEventLoop")
            thread.start()
            XuanpingBrowserServiceSync._shared_thread = thread

            # ç­‰å¾…äº‹ä»¶å¾ªç¯å‡†å¤‡å°±ç»ª
            import time
            max_wait = 5  # æœ€å¤šç­‰å¾…5ç§’
            waited = 0
            while XuanpingBrowserServiceSync._shared_loop is None and waited < max_wait:
                time.sleep(0.1)
                waited += 0.1

            if XuanpingBrowserServiceSync._shared_loop is None:
                raise RuntimeError("å…±äº«äº‹ä»¶å¾ªç¯åˆ›å»ºå¤±è´¥")

            self.logger.info("âœ… å…±äº«äº‹ä»¶å¾ªç¯å‡†å¤‡å°±ç»ª")

    def _run_async(self, coro):
        """
        è¿è¡Œå¼‚æ­¥å‡½æ•° - ğŸ”§ å…³é”®ä¿®å¤ï¼šåœ¨å…±äº«äº‹ä»¶å¾ªç¯ä¸­æ‰§è¡Œæ‰€æœ‰å¼‚æ­¥æ“ä½œ

        è¿™ç¡®ä¿äº†æ‰€æœ‰ Playwright å¯¹è±¡å§‹ç»ˆåœ¨åŒä¸€ä¸ªäº‹ä»¶å¾ªç¯ä¸­æ“ä½œï¼Œ
        ä»è€Œå½»åº•è§£å†³ "The future belongs to a different loop" é”™è¯¯
        """
        try:
            # ç¡®ä¿å…±äº«äº‹ä»¶å¾ªç¯æ­£åœ¨è¿è¡Œ
            if (XuanpingBrowserServiceSync._shared_loop is None or
                not XuanpingBrowserServiceSync._shared_loop.is_running()):
                self._ensure_shared_loop()

            # åœ¨å…±äº«äº‹ä»¶å¾ªç¯ä¸­æ‰§è¡Œåç¨‹
            future = asyncio.run_coroutine_threadsafe(
                coro,
                XuanpingBrowserServiceSync._shared_loop
            )

            # ç­‰å¾…ç»“æœï¼ˆ60ç§’è¶…æ—¶ï¼‰
            return future.result(timeout=60)

        except Exception as e:
            self.logger.error(f"âŒ å¼‚æ­¥å‡½æ•°æ‰§è¡Œå¤±è´¥: {e}")
            raise


    
    def initialize(self) -> bool:
        """
        åŒæ­¥åˆå§‹åŒ–

        ğŸ”§ Task 4.3 (P1-8): åˆå§‹åŒ–æˆåŠŸåè‡ªåŠ¨æ›´æ–°æµè§ˆå™¨å¯¹è±¡
        """
        result = self._run_async(self.async_service.initialize())
        if result:
            # ğŸ”§ Task 4.3: åˆå§‹åŒ–æˆåŠŸåå°è¯•æ›´æ–°æµè§ˆå™¨å¯¹è±¡
            # æ³¨æ„ï¼šåˆå§‹åŒ–åå¯èƒ½è¿˜æ²¡æœ‰ page å¯¹è±¡ï¼Œæ‰€ä»¥è¿™é‡Œå¯èƒ½ä¼šå¤±è´¥ï¼Œè¿™æ˜¯æ­£å¸¸çš„
            try:
                self._update_browser_objects()
            except BrowserError:
                # åˆå§‹åŒ–åå¯èƒ½è¿˜æ²¡æœ‰ pageï¼Œè¿™æ˜¯æ­£å¸¸çš„ï¼Œå¿½ç•¥é”™è¯¯
                pass
        return result
    
    def start_browser(self) -> bool:
        """åŒæ­¥å¯åŠ¨æµè§ˆå™¨ï¼Œå¹¶æ›´æ–°æš´éœ²çš„å±æ€§"""
        result = self._run_async(self.async_service.start_browser())
        if result:
            # æ›´æ–°æš´éœ²çš„å±æ€§
            self._update_browser_objects()
        return result

    def _update_browser_objects(self):
        """
        æ›´æ–°æš´éœ²çš„æµè§ˆå™¨å¯¹è±¡

        ğŸ”§ Task 4.1 (P0-6): ç®€åŒ–è®¿é—®è·¯å¾„ï¼Œæ·»åŠ é€å±‚éªŒè¯
        ğŸ”§ Task 4.2 (P0-1): å¢å¼ºé”™è¯¯å¤„ç†ï¼Œå¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸
        """
        try:
            # ğŸ”§ Task 4.1: é€å±‚éªŒè¯ï¼Œæä¾›æ˜ç¡®çš„é”™è¯¯ä¿¡æ¯

            # ç¬¬ 1 å±‚ï¼šéªŒè¯ async_service
            if not self.async_service:
                raise BrowserError("async_service is None - XuanpingBrowserService not initialized")

            # ç¬¬ 2 å±‚ï¼šéªŒè¯ browser_service
            if not hasattr(self.async_service, 'browser_service') or not self.async_service.browser_service:
                raise BrowserError("browser_service is None - SimplifiedBrowserService not initialized")

            browser_service = self.async_service.browser_service

            # ç¬¬ 3 å±‚ï¼šéªŒè¯ browser_driver
            if not hasattr(browser_service, 'browser_driver') or not browser_service.browser_driver:
                raise BrowserError("browser_driver is None - PlaywrightBrowserDriver not initialized")

            driver = browser_service.browser_driver

            # ç¬¬ 4 å±‚ï¼šéªŒè¯æµè§ˆå™¨å¯¹è±¡
            if not hasattr(driver, 'page') or not driver.page:
                raise BrowserError("page is None - Browser page not created")

            if not hasattr(driver, 'browser'):
                raise BrowserError("browser attribute not found on driver")

            if not hasattr(driver, 'context'):
                raise BrowserError("context attribute not found on driver")

            # æ‰€æœ‰éªŒè¯é€šè¿‡ï¼Œæ›´æ–°å¯¹è±¡
            self.page = driver.page
            self.browser = driver.browser
            self.context = driver.context

            self.logger.debug("âœ… æµè§ˆå™¨å¯¹è±¡å·²æ›´æ–°")

        except BrowserError:
            # ğŸ”§ Task 4.2: BrowserError ç›´æ¥å‘ä¸ŠæŠ›å‡º
            raise
        except (AttributeError, TypeError) as e:
            # ğŸ”§ Task 4.2: å…¶ä»–å¼‚å¸¸åŒ…è£…ä¸º BrowserError å¹¶æŠ›å‡º
            self.logger.error(f"âŒ æ›´æ–°æµè§ˆå™¨å¯¹è±¡å¤±è´¥: {e}")
            raise BrowserError(f"Failed to update browser objects: {e}") from e
    
    def navigate_to(self, url: str) -> bool:
        """
        åŒæ­¥å¯¼èˆª

        ğŸ”§ Task 4.3 (P1-8): å¯¼èˆªæˆåŠŸåè‡ªåŠ¨æ›´æ–°æµè§ˆå™¨å¯¹è±¡
        """
        result = self._run_async(self.async_service.navigate_to(url))
        if result:
            # ğŸ”§ Task 4.3: å¯¼èˆªæˆåŠŸåè‡ªåŠ¨æ›´æ–°æµè§ˆå™¨å¯¹è±¡
            self._update_browser_objects()
        return result
    
    def scrape_page_data(self, url: str, extractor_func) -> ScrapingResult:
        """
        åŒæ­¥æŠ“å–æ•°æ® - ä¼ é€’ self ä»¥ä¾¿æå–å‡½æ•°å¯ä»¥è®¿é—® page å±æ€§

        ğŸ”§ Task 4.4 (P1-10): å¢å¼ºå¼‚æ­¥/åŒæ­¥è¾¹ç•Œå®‰å…¨æ€§
        """
        async def wrapper_extractor(browser_service):
            # ğŸ”§ Task 4.4: åœ¨æå–æ•°æ®å‰ï¼Œç¡®ä¿æµè§ˆå™¨å¯¹è±¡å·²æ›´æ–°
            # å› ä¸º navigate_to å¯èƒ½ä¼šå¯åŠ¨æµè§ˆå™¨ï¼Œä½†ä¸ä¼šè‡ªåŠ¨æ›´æ–°åŒæ­¥åŒ…è£…å™¨çš„å±æ€§
            try:
                self._update_browser_objects()
            except BrowserError as e:
                # ğŸ”§ Task 4.4: å¦‚æœæ›´æ–°å¤±è´¥ï¼Œæä¾›æ˜ç¡®çš„é”™è¯¯ä¿¡æ¯
                self.logger.error(f"âŒ æ›´æ–°æµè§ˆå™¨å¯¹è±¡å¤±è´¥ï¼Œæ— æ³•æå–æ•°æ®: {e}")
                raise

            # ä¼ é€’ self è€Œä¸æ˜¯ browser_serviceï¼Œè¿™æ ·æå–å‡½æ•°å¯ä»¥è®¿é—® self.page
            return await extractor_func(self)

        return self._run_async(self.async_service.scrape_page_data(url, wrapper_extractor))
    
    def close(self) -> bool:
        """åŒæ­¥å…³é—­"""
        return self._run_async(self.async_service.close())
    
    def __enter__(self):
        """åŒæ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨å…¥å£"""
        self.initialize()
        self.start_browser()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """åŒæ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨å‡ºå£"""
        self.close()


# å¯¼å‡º
__all__ = [
    'XuanpingBrowserService',
    'XuanpingBrowserServiceSync',
    'create_xuanping_browser_service'
]