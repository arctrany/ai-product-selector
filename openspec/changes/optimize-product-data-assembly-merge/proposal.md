# 优化商品数据组装合并流程

## Why (为什么需要这个变更)

当前商品抓取生命周期的数据组装合并流程存在以下关键问题：

### 1. 数据结构不一致
- **问题**: `ScrapingOrchestrator._evaluate_data_completeness()` 期望嵌套结构 (`price_data.green_price`, `erp_data.purchase_price`)
- **现实**: `OzonScraper` 返回扁平结构 (`green_price`, `source_price`)
- **影响**: 数据完整度评估失效，导致错误的商品选择决策

### 2. 利润计算字段缺失
- **问题**: 数据完整度评估缺少利润计算器必需的关键字段
- **缺失字段**: `list_price`, `real_selling_price`, 完整的物理属性 (weight, length, width, height)
- **影响**: 无法准确进行后续的利润计算和商品评估

### 3. 职责分配不清晰
- **问题**: `ScrapingOrchestrator` 承担了业务逻辑计算职责，违背了单一职责原则
- **现状**: 协调器既负责数据抓取协调，又负责商品选择决策
- **影响**: 代码耦合度高，难以维护和扩展

### 4. 数据传输效率低
- **问题**: 冗余字段和重复数据结构
- **现状**: `is_competitor` 字段多处重复，`selected_product` 包含完整商品数据而非引用
- **影响**: 内存占用高，数据传输效率低

## What (要实现什么)

### 核心目标
重构商品数据组装合并流程，实现：
1. **协调器职责简化**: 只负责原始数据组装，不进行业务计算
2. **GoodStoreSelector职责增强**: 负责商品合并决策和利润计算准备
3. **数据结构标准化**: 统一使用 `ProductInfo` 作为数据容器
4. **合并策略优化**: 基于利润计算关键字段的完整性进行决策

### 预期效果
- 数据完整度评估准确率提升至 95%+
- 代码耦合度降低，单一职责原则得到遵守
- 内存使用效率提升 30%+
- 为后续利润计算提供完整、准确的数据基础

## How (如何实现)

### 阶段1: 协调器数据组装优化
- 简化 `ScrapingOrchestrator` 职责，只负责原始数据收集和组装
- 移除业务逻辑计算，专注数据抓取协调
- 输出标准化的 `ProductInfo` 对象

### 阶段2: GoodStoreSelector合并逻辑实现
- 在 `GoodStoreSelector` 中实现 `merge_and_compute()` 方法
- 基于利润计算关键字段完整性进行商品选择
- 为利润计算器准备完整的数据输入

### 阶段3: 数据结构标准化
- 统一使用 `ProductInfo` 作为数据传输对象
- 移除冗余字段和重复数据结构
- 优化数据传输效率

### 阶段4: 测试和验证
- 更新集成测试以验证新的数据流
- 性能测试验证内存和效率提升
- 端到端测试确保利润计算准确性

## 风险和缓解措施

### 主要风险
1. **破坏性变更**: 现有集成测试和下游代码可能受影响
2. **数据一致性**: 重构过程中可能出现数据格式不一致
3. **性能回归**: 新的数据流可能影响性能

### 缓解措施
1. **分阶段实施**: 逐步重构，确保每个阶段的稳定性
2. **全面测试**: 创建完整的测试套件验证数据一致性
3. **性能监控**: 实时监控关键指标，及时发现性能问题

## 成功标准

### 技术指标
- [ ] 数据完整度评估准确率 ≥ 95%
- [ ] 单元测试覆盖率 ≥ 90%
- [ ] 集成测试通过率 = 100%
- [ ] 内存使用效率提升 ≥ 30%

### 业务指标
- [ ] 利润计算准确性验证通过
- [ ] 商品选择逻辑符合业务需求
- [ ] 数据流端到端验证成功

### 代码质量指标
- [ ] 代码耦合度降低，符合单一职责原则
- [ ] 数据结构标准化，使用统一的 `ProductInfo` 模型
- [ ] 错误处理机制完善，异常场景覆盖完整