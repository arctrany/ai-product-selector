
"""
æ”¹è¿›çš„ScraperåŸºç±»

æä¾›æ‰€æœ‰scraperçš„é€šç”¨åŠŸèƒ½ï¼ŒåŒ…æ‹¬åŒæ­¥çš„é¡µé¢æ•°æ®æŠ“å–æ–¹æ³•å’Œèµ„æºæ¸…ç†ã€‚
å°†ä¸šåŠ¡é€»è¾‘ï¼ˆæ•°æ®æŠ“å–æµç¨‹ï¼‰ä¸æŠ€æœ¯å±‚ï¼ˆæµè§ˆå™¨æœåŠ¡ï¼‰åˆ†ç¦»ã€‚
ç»Ÿä¸€å¤„ç†äº‹ä»¶å¾ªç¯é—®é¢˜ï¼Œé¿å…åœ¨å„ä¸ªscraperä¸­é‡å¤å®ç°ã€‚
"""

import asyncio
import time
import logging
from typing import Any, Callable, Optional

from .browser_service_wrapper import BrowserServiceWrapper
from ..models import ScrapingResult


class BaseScraperImproved:
    """
    æ”¹è¿›çš„ScraperåŸºç±»
    
    æä¾›é€šç”¨çš„æ•°æ®æŠ“å–åŠŸèƒ½ï¼š
    1. scrape_page_data - åŒæ­¥çš„é¡µé¢æ•°æ®æŠ“å–æ–¹æ³•
    2. ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
    3. æ‰§è¡Œæ—¶é—´ç»Ÿè®¡
    4. èµ„æºæ¸…ç†å’Œææ„å‡½æ•°
    5. ç»Ÿä¸€çš„äº‹ä»¶å¾ªç¯å¤„ç†
    """
    
    def __init__(self, browser_service: Optional[Any] = None):
        """
        åˆå§‹åŒ–åŸºç±»
        
        Args:
            browser_service: å¯é€‰çš„æµè§ˆå™¨æœåŠ¡å®ä¾‹
        """
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        self.browser_service_wrapper = BrowserServiceWrapper(browser_service) if browser_service else None
    
    def scrape_page_data(self, url: str, extractor_func: Callable) -> ScrapingResult:
        """
        åŒæ­¥æŠ“å–é¡µé¢æ•°æ®
        
        è¿™æ˜¯ä¸€ä¸ªä¸šåŠ¡å±‚çš„ä¾¿æ·æ–¹æ³•ï¼Œå°è£…äº†å®Œæ•´çš„æ•°æ®æŠ“å–æµç¨‹ï¼š
        1. å¯¼èˆªåˆ°ç›®æ ‡URL
        2. ç­‰å¾…é¡µé¢åŠ è½½
        3. æå–æ•°æ®
        4. è¿”å›ç»“æœ
        
        Args:
            url: ç›®æ ‡é¡µé¢URL
            extractor_func: æ•°æ®æå–å‡½æ•°ï¼ˆå¼‚æ­¥ï¼‰ï¼Œæ¥æ”¶ browser_service_wrapper å‚æ•°
            
        Returns:
            ScrapingResult: æŠ“å–ç»“æœå¯¹è±¡
            
        ä½¿ç”¨ç¤ºä¾‹:
            async def extract_data(browser_service_wrapper):
                content = await browser_service_wrapper.get_page_content()
                return parse_content(content)
            
            result = self.scrape_page_data(url, extract_data)
            if result.success:
                data = result.data
        """
        start_time = time.time()
        
        try:
            # æ£€æŸ¥æ˜¯å¦æœ‰ browser_service_wrapper
            if not self.browser_service_wrapper:
                raise AttributeError(
                    f"{self.__class__.__name__} å¿…é¡»è®¾ç½® browser_service_wrapper å±æ€§"
                )
            
            # å®šä¹‰å¼‚æ­¥æ‰§è¡Œå‡½æ•°
            async def async_scrape():
                try:
                    # 1. å¯¼èˆªåˆ°é¡µé¢
                    success = await self.browser_service_wrapper.navigate_to(url)
                    if not success:
                        return ScrapingResult(
                            success=False,
                            data={},
                            error_message="é¡µé¢å¯¼èˆªå¤±è´¥",
                            execution_time=time.time() - start_time
                        )
                    
                    # 2. ç­‰å¾…é¡µé¢åŠ è½½
                    await asyncio.sleep(1)
                    
                    # 3. æå–æ•°æ® - ä¼ é€’ browser_service_wrapper
                    data = await extractor_func(self.browser_service_wrapper)
                    
                    # 4. è¿”å›æˆåŠŸç»“æœ
                    return ScrapingResult(
                        success=True,
                        data=data,
                        execution_time=time.time() - start_time
                    )
                    
                except Exception as e:
                    self.logger.error(f"âŒ å¼‚æ­¥æ•°æ®æŠ“å–å¤±è´¥: {e}")
                    return ScrapingResult(
                        success=False,
                        data={},
                        error_message=str(e),
                        execution_time=time.time() - start_time
                    )
            
            # åŒæ­¥æ‰§è¡Œå¼‚æ­¥å‡½æ•° - äº‹ä»¶å¾ªç¯å¤„ç†ç”±BrowserServiceWrapperç»Ÿä¸€å¤„ç†
            return asyncio.run(async_scrape())
            
        except Exception as e:
            execution_time = time.time() - start_time
            self.logger.error(f"âŒ é¡µé¢æ•°æ®æŠ“å–å¤±è´¥: {e}")
            
            return ScrapingResult(
                success=False,
                data={},
                error_message=str(e),
                execution_time=execution_time
            )
    
    def close(self):
        """
        å…³é—­æŠ“å–å™¨ï¼Œæ¸…ç†èµ„æº
        
        å­ç±»åº”è¯¥é‡å†™æ­¤æ–¹æ³•ä»¥å®ç°ç‰¹å®šçš„èµ„æºæ¸…ç†é€»è¾‘ã€‚
        åŸºç±»æä¾›é€šç”¨çš„èµ„æºæ¸…ç†æœºåˆ¶ï¼š
        1. å…³é—­ browser_serviceï¼ˆå¦‚æœå­˜åœ¨ä¸”éœ€è¦å…³é—­ï¼‰
        2. å…³é—­å…¶ä»– scraper ç»„ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        """
        try:
            # å…³é—­ browser_service
            if self.browser_service_wrapper:
                try:
                    asyncio.run(self.browser_service_wrapper.close())
                    self.logger.info(f"ğŸ”’ {self.__class__.__name__} æµè§ˆå™¨æœåŠ¡å·²å…³é—­")
                except Exception as e:
                    self.logger.warning(f"å…³é—­æµè§ˆå™¨æœåŠ¡æ—¶å‡ºé”™: {e}")
            
            # å…³é—­å…¶ä»– scraper ç»„ä»¶
            # æŸ¥æ‰¾æ‰€æœ‰ä»¥ '_scraper' ç»“å°¾çš„å±æ€§å¹¶å°è¯•å…³é—­å®ƒä»¬
            for attr_name in dir(self):
                if attr_name.endswith('_scraper') and attr_name != 'browser_service_wrapper':
                    scraper = getattr(self, attr_name)
                    if scraper and hasattr(scraper, 'close'):
                        try:
                            scraper.close()
                            self.logger.info(f"ğŸ”’ {self.__class__.__name__}.{attr_name} å·²å…³é—­")
                        except Exception as e:
                            self.logger.warning(f"å…³é—­ {attr_name} æ—¶å‡ºé”™: {e}")
                            
        except Exception as e:
            self.logger.error(f"å…³é—­ {self.__class__.__name__} æ—¶å‘ç”Ÿé”™è¯¯: {e}")
    
    def __del__(self):
        """
        ææ„å‡½æ•°ï¼Œç¡®ä¿èµ„æºè¢«æ­£ç¡®é‡Šæ”¾
        """
        try:
            self.close()
        except:
            pass
    
    def __enter__(self):
        """ä¸Šä¸‹æ–‡ç®¡ç†å™¨å…¥å£"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """ä¸Šä¸‹æ–‡ç®¡ç†å™¨å‡ºå£"""
        self.close()
