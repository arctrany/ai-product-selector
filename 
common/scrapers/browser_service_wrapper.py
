
"""
浏览器服务包装器

统一处理浏览器服务的事件循环问题，避免在各个scraper中重复实现。
"""

import asyncio
import logging
from typing import Any, Callable, Optional


class BrowserServiceWrapper:
    """浏览器服务包装器，统一处理事件循环问题"""
    
    def __init__(self, browser_service: Any):
        """
        初始化浏览器服务包装器
        
        Args:
            browser_service: 浏览器服务实例
        """
        self.browser_service = browser_service
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
    
    async def _run_in_event_loop(self, coro):
        """
        在当前事件循环中运行协程
        
        Args:
            coro: 要运行的协程
            
        Returns:
            协程的执行结果
        """
        try:
            loop = asyncio.get_running_loop()
            # 在当前事件循环中创建任务
            future = asyncio.run_coroutine_threadsafe(coro, loop)
            return await asyncio.wrap_future(future)
        except RuntimeError:
            # 不在事件循环中，直接运行
            return await coro
    
    async def navigate_to(self, url: str) -> bool:
        """
        导航到指定URL
        
        Args:
            url: 目标URL
            
        Returns:
            导航是否成功
        """
        try:
            if hasattr(self.browser_service, 'navigate_to_sync'):
                return self.browser_service.navigate_to_sync(url)
            else:
                return await self._run_in_event_loop(self.browser_service.navigate_to(url))
        except Exception as e:
            self.logger.error(f"导航到 {url} 失败: {e}")
            return False
    
    async def get_page_content(self) -> Optional[str]:
        """
        获取页面内容
        
        Returns:
            页面内容，失败时返回None
        """
        try:
            return await self._run_in_event_loop(self.browser_service.get_page_content())
        except Exception as e:
            self.logger.error(f"获取页面内容失败: {e}")
            return None
    
    async def close(self):
        """关闭浏览器服务"""
        try:
            await self._run_in_event_loop(self.browser_service.close())
        except Exception as e:
            self.logger.error(f"关闭浏览器服务失败: {e}")
    
    async def execute_script(self, script: str) -> Any:
        """
        执行JavaScript脚本
        
        Args:
            script: 要执行的JavaScript代码
            
        Returns:
            脚本执行结果
        """
        try:
            return await self._run_in_event_loop(self.browser_service.execute_script(script))
        except Exception as e:
            self.logger.error(f"执行脚本失败: {e}")
            return None
